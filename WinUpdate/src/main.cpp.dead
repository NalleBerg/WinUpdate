#include <windows.h>
#include <commctrl.h>
#include <shellapi.h>
#include "../resource.h"
#include <string>
#include <atomic>
#include <vector>
#include <sstream>
#include <set>
#include <regex>
#include <fstream>
#include <thread>
#include <mutex>
#include <atomic>
#include <chrono>
#include <filesystem>
#include <unordered_map>
#include <future>
#include <unordered_set>
#include <filesystem>
#include "About.h"
#include "skip_update.h"
#include "parsing.h"
// detect nlohmann/json.hpp if available; fall back to ad-hoc parser otherwise
#if defined(__has_include)
#  if __has_include(<nlohmann/json.hpp>)
#    include <nlohmann/json.hpp>
#    define HAVE_NLOHMANN_JSON 1
#  else
#    define HAVE_NLOHMANN_JSON 0
#  endif
#else
#  define HAVE_NLOHMANN_JSON 0
#endif

// Very-very-early static initializer to record process start even before wWinMain.
struct StartupStaticProbe {
    StartupStaticProbe() {
        try {
            const wchar_t *p = L"logs\startup_static_init.txt";
            CreateDirectoryW(L"logs", NULL);
            HANDLE hf = CreateFileW(p, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
            if (hf != INVALID_HANDLE_VALUE) {
                std::string s = "startup_static_init PID=" + std::to_string(GetCurrentProcessId()) + "\n";
                DWORD w = 0; WriteFile(hf, s.data(), (DWORD)s.size(), &w, NULL);
                CloseHandle(hf);
            }
        } catch(...) {}
    }
};
static StartupStaticProbe g_startup_static_probe;

// Small helper that writes a UTF-8 narrow string into the workspace logs folder
static void WriteWorkspaceLogW(const wchar_t *fname, const std::string &content) {
    // Respect global logging toggle
    extern std::atomic<bool> g_enable_logging;
    if (!g_enable_logging.load()) return;
    // absolute workspace path (explicit to avoid CWD ambiguity during packaged runs)
    const wchar_t *workspaceLogs = L"C:\\Users\\NalleBerg\\Documents\\C++\\Workspace\\WinUpdate\\logs";
    CreateDirectoryW(workspaceLogs, NULL);
    std::wstring full = std::wstring(workspaceLogs) + L"\\" + std::wstring(fname);
    HANDLE hf = CreateFileW(full.c_str(), GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hf != INVALID_HANDLE_VALUE) {
        DWORD written = 0;
        WriteFile(hf, content.data(), (DWORD)content.size(), &written, NULL);
        CloseHandle(hf);
    }
}

static void ForceApplyHeaderTexts(HWND hList) {
    if (!hList) return;
    HWND hHeader = ListView_GetHeader(hList);
    if (!hHeader) return;
    for (int ci = 0; ci < 4; ++ci) {
        HDITEMW hi{};
        hi.mask = HDI_TEXT | HDI_FORMAT;
        if (ci == 0) hi.fmt = HDF_LEFT;
        else if (ci == 1) hi.fmt = HDF_LEFT; // Installed header text left
        else if (ci == 2) hi.fmt = HDF_RIGHT; // Available header text right
        else hi.fmt = HDF_CENTER;
        // Use centralized parsing implementations in src/parsing.cpp
    std::string ident_l = toLower(ident);
    // canonical map quick checks
    const std::vector<std::pair<std::string,std::string>> canon = { {"vulkan sdk","KhronosGroup.VulkanSDK"}, {"khronos vulkan","KhronosGroup.VulkanSDK"} };
    for (auto &c : canon) if (ident_l.find(c.first) != std::string::npos) return c.second;
    // tokenize for fuzzy matching
    auto tokenize = [](const std::string &x){ std::vector<std::string> out; std::string cur; for (char c : x) { if (isalnum((unsigned char)c)) cur.push_back((char)tolower((unsigned char)c)); else { if (!cur.empty()) { out.push_back(cur); cur.clear(); } } } if (!cur.empty()) out.push_back(cur); return out; };
    auto tokens = tokenize(ident_l);
    std::lock_guard<std::mutex> lk(g_packages_mutex);
    // 1) exact name match
    for (auto &p : g_packages) if (p.second == ident) return p.first;
    // 2) case-insensitive exact or substring match on name
    for (auto &p : g_packages) { std::string nm_l = toLower(p.second); if (nm_l == ident_l || nm_l.find(ident_l) != std::string::npos || ident_l.find(nm_l) != std::string::npos) return p.first; }
    // 3) token-subset match against name
    if (!tokens.empty()) {
        for (auto &p : g_packages) {
            std::string nm_l = toLower(p.second);
            bool all = true;
            for (auto &t : tokens) if (nm_l.find(t) == std::string::npos) { all = false; break; }
            if (all) return p.first;
        }
    }
    // 4) token-subset match against id
    if (!tokens.empty()) {
        for (auto &p : g_packages) {
            std::string idl = toLower(p.first);
            bool all = true;
            for (auto &t : tokens) if (idl.find(t) == std::string::npos) { all = false; break; }
            if (all) return p.first;
        }
    }
    return std::string();
}

// Load/Save per-locale skip config in i18n/<locale>.ini with lines: skip=Id|Version
static void LoadSkipConfig(const std::string &locale) {
    // Load skipped entries from the per-user settings INI (APPDATA) via skip_update helpers.
    g_skipped_versions.clear();
    try {
        auto m = LoadSkippedMap();
        for (auto &p : m) g_skipped_versions[p.first] = p.second;
    } catch(...) {}
}

static void SaveSkipConfig(const std::string &locale) {
    try {
        std::map<std::string,std::string> m;
        for (auto &p : g_skipped_versions) m[p.first] = p.second;
        SaveSkippedMap(m);
    } catch(...) {}
}

static std::unordered_map<std::string,std::string> MapInstalledVersions() {
    std::unordered_map<std::string,std::string> out;
    try {
        auto r = RunProcessCaptureExitCode(L"winget list", 3000);
        std::string txt = r.second;
        std::istringstream iss(txt);
        std::string ln;
        while (std::getline(iss, ln)) {
            // skip separators or headers
            if (ln.find("----") != std::string::npos) continue;
            if (ln.find("Name") != std::string::npos && ln.find("Id") != std::string::npos) continue;
            // trim
            auto trim = [](std::string &s){ while(!s.empty() && (s.back()=='\r' || s.back()=='\n')) s.pop_back(); while(!s.empty() && isspace((unsigned char)s.front())) s.erase(s.begin()); while(!s.empty() && isspace((unsigned char)s.back())) s.pop_back(); };
            trim(ln);
            if (ln.empty()) continue;
            // split by whitespace into tokens
            std::istringstream ls(ln);
            std::vector<std::string> toks;
            std::string tok;
            while (ls >> tok) toks.push_back(tok);
            if (toks.size() < 2) continue;
            // build known id set from current package list to improve matching
            std::unordered_set<std::string> knownIds;
            {
                std::lock_guard<std::mutex> lk(g_packages_mutex);
                for (auto &p : g_packages) knownIds.insert(p.first);
            }
            // prefer matching a token that equals a known id; fall back to heuristic
            std::string id;
            for (auto &t : toks) {
                if (knownIds.find(t) != knownIds.end()) { id = t; break; }
            }
            if (id.empty()) {
                if (toks.size() >= 3) id = toks[toks.size()-3];
                else id = toks.front();
            }
            std::string inst = toks.size() >= 2 ? toks[toks.size()-2] : std::string();
            out[id] = inst;
        }
    } catch(...) {}
    return out;
}

// Map id -> available version by parsing `winget upgrade` table quickly
static std::unordered_map<std::string,std::string> MapAvailableVersions() {
    std::unordered_map<std::string,std::string> out;
    try {
        auto r = RunProcessCaptureExitCode(L"winget upgrade", 5000);
        std::string txt = r.second;
        std::istringstream iss(txt);
        std::string ln;
        while (std::getline(iss, ln)) {
            // skip separators/headers
            if (ln.find("----") != std::string::npos) continue;
            if (ln.find("Name") != std::string::npos && ln.find("Id") != std::string::npos) continue;
            // trim
            auto trim = [](std::string &s){ while(!s.empty() && (s.back()=='\r' || s.back()=='\n')) s.pop_back(); while(!s.empty() && isspace((unsigned char)s.front())) s.erase(s.begin()); while(!s.empty() && isspace((unsigned char)s.back())) s.pop_back(); };
            trim(ln);
            if (ln.empty()) continue;
            // tokenize by whitespace
            std::istringstream ls(ln);
            std::vector<std::string> toks;
            std::string tok;
            while (ls >> tok) toks.push_back(tok);
            if (toks.empty()) continue;
            // build known id set from current package list to improve matching
            std::unordered_set<std::string> knownIds;
            {
                std::lock_guard<std::mutex> lk(g_packages_mutex);
                for (auto &p : g_packages) knownIds.insert(p.first);
            }
            std::string id;
            for (auto &t : toks) {
                if (knownIds.find(t) != knownIds.end()) { id = t; break; }
            }
            if (id.empty()) {
                if (toks.size() >= 3) id = toks[toks.size()-3];
                else id = toks.front();
            }
            std::string available = toks.back();
            if (!id.empty()) {
                try {
                    // Direct skip check
                    if (IsSkipped(id, available)) continue;
                } catch(...) {}
                // Fallback: try resolving the id/name to a canonical id and check again
                try {
                    std::string resolved = ResolveIdForName(id);
                    if (resolved.empty()) resolved = ResolveIdForName(toks.front());
                    if (!resolved.empty()) {
                        try { if (IsSkipped(resolved, available)) continue; } catch(...) {}
                        // prefer resolved id as the map key so later lookups match g_packages
                        out[resolved] = available; continue;
                    }
                } catch(...) {}
                out[id] = available;
            }
        }
    } catch(...) {}
    return out;
}

static void InitDefaultTranslations() {
    if (!g_i18n_default.empty()) return;
    g_i18n_default["app_window_title"] = "WinUpdate - winget GUI updater";
    g_i18n_default["app_title"] = "WinUpdate";
    // suffix used when building the main window title (keeps app name untranslated in code)
    g_i18n_default["app_window_suffix"] = "winget GUI updater";
    g_i18n_default["list_last_updated_prefix"] = "List last updated:";
    g_i18n_default["select_all"] = "Select all";
    g_i18n_default["upgrade_now"] = "Install updates";
    g_i18n_default["refresh"] = "Refresh";
    g_i18n_default["lang_changed"] = "Language changed to English (UK)";
    g_i18n_default["package_col"] = "Package";
    g_i18n_default["id_col"] = "Id";
    g_i18n_default["current_col"] = "Installed";
    g_i18n_default["available_col"] = "Available";
    g_i18n_default["skip_col"] = "Skip";
    g_i18n_default["loading_title"] = "Loading, please";
    g_i18n_default["loading_desc"] = "Querying winget";
    g_i18n_default["your_system_updated"] = "Your system is updated!";
    g_i18n_default["your_system_updated"] = "Your system is up to date";
    g_i18n_default["msg_error_elevate"] = "Failed to launch elevated process.";
}

static void LoadLocaleFromFile(const std::string &locale) {
    g_i18n = g_i18n_default; // start with defaults
    std::string path = std::string("i18n\\") + locale + ".txt";
    std::string txt = ReadFileUtf8(std::wstring(path.begin(), path.end()));
    if (txt.empty()) return;
    std::istringstream iss(txt);
    std::string ln;
    while (std::getline(iss, ln)) {
        // Trim
        auto ltrim = [](std::string &s){ while(!s.empty() && (s.front()==' '||s.front()=='\t' || s.front()=='\r')) s.erase(s.begin()); };
        auto rtrim = [](std::string &s){ while(!s.empty() && (s.back()==' '||s.back()=='\t' || s.back()=='\r' || s.back()=='\n')) s.pop_back(); };
        ltrim(ln); rtrim(ln);
        if (ln.empty()) continue;
        if (ln[0] == '#' || ln[0] == ';') continue;
        size_t eq = ln.find('=');
        if (eq == std::string::npos) continue;
        std::string key = ln.substr(0, eq);
        std::string val = ln.substr(eq+1);
        ltrim(key); rtrim(key); ltrim(val); rtrim(val);
        if (!key.empty()) g_i18n[key] = val;
    }
}

static std::wstring t(const char *key) {
    InitDefaultTranslations();
    std::string k(key);
    auto it = g_i18n.find(k);
    if (it == g_i18n.end()) it = g_i18n_default.find(k);
    if (it == g_i18n_default.end()) return Utf8ToWide(k);
    return Utf8ToWide(it->second);
}

// Settings persistence: simple UTF-8 key=value in wup_settings.txt
static bool SaveLocaleSetting(const std::string &locale) {
    try {
        std::string fn = "wup_settings.txt";
        std::ofstream ofs(fn, std::ios::binary | std::ios::trunc);
        if (!ofs) return false;
        ofs << "language=" << locale << "\n";
        return true;
    } catch(...) { return false; }
}

static std::string LoadLocaleSetting() {
    try {
        std::string fn = "wup_settings.txt";
        std::ifstream ifs(fn, std::ios::binary);
        if (!ifs) return std::string();
        std::ostringstream ss; ss << ifs.rdbuf();
        std::string txt = ss.str();
        std::istringstream iss(txt);
        std::string ln;
        while (std::getline(iss, ln)) {
            // trim
            auto ltrim = [](std::string &s){ while(!s.empty() && isspace((unsigned char)s.front())) s.erase(s.begin()); };
            auto rtrim = [](std::string &s){ while(!s.empty() && isspace((unsigned char)s.back())) s.pop_back(); };
            ltrim(ln); rtrim(ln);
            if (ln.empty()) continue;
            if (ln[0] == '#' || ln[0] == ';') continue;
            size_t eq = ln.find('=');
            if (eq == std::string::npos) continue;
            std::string key = ln.substr(0, eq);
            std::string val = ln.substr(eq+1);
            ltrim(key); rtrim(key); ltrim(val); rtrim(val);
            if (key == "language" && !val.empty()) return val;
        }
    } catch(...) {}
    return std::string();
}

static LRESULT CALLBACK PopupWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
static LRESULT CALLBACK AnimSubclassProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam,
    UINT_PTR uIdSubclass, DWORD_PTR dwRefData);
static LRESULT CALLBACK HeaderSubclassProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR, DWORD_PTR);
static LRESULT CALLBACK HeaderSubclassProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData) {
    switch (uMsg) {
    case WM_PAINT: {
        // let default header paint first
        LRESULT def = DefSubclassProc(hwnd, uMsg, wParam, lParam);
        // then draw our text on top to force visibility
        HWND hList = GetParent(hwnd);
        if (!hList) return def;
        RECT rc; GetClientRect(hwnd, &rc);
        HDC hdc = GetDC(hwnd);
        if (!hdc) return def;
        HFONT hf = (HFONT)SendMessageW(hList, WM_GETFONT, 0, 0);
        if (hf) SelectObject(hdc, hf);
        SetBkMode(hdc, TRANSPARENT);
        COLORREF txt = GetSysColor(COLOR_BTNTEXT);
        SetTextColor(hdc, txt);
        // iterate columns and draw text into each header slot
        int x = 0;
        for (int ci = 0; ci < 4; ++ci) {
            int w = ListView_GetColumnWidth(hList, ci);
            RECT r = { x, rc.top, x + w, rc.bottom };
            UINT flags = DT_SINGLELINE | DT_VCENTER | DT_NOPREFIX;
            if (ci == 0) flags |= DT_LEFT;
            else if (ci == 1) flags |= DT_LEFT;
            else if (ci == 2) flags |= DT_RIGHT;
            else flags |= DT_CENTER;
            // copy header text into a local variable before drawing
            std::wstring headerText = (ci >= 0 && ci < (int)g_colHeaders.size()) ? g_colHeaders[ci] : std::wstring();
            DrawTextW(hdc, headerText.c_str(), (int)headerText.size(), &r, flags);
            // append to paint dump for diagnostic logging
            try {
                // accumulate narrow UTF-8 text
                std::string s = WideToUtf8(headerText);
                static std::string paint_acc;
                if (!paint_acc.empty()) paint_acc += "\n";
                paint_acc += s;
                // when last column, write out files
                if (ci == 3) {
                    // workspace-relative logs folder (use current directory + \logs)
                    {
                        wchar_t cwdBuf[MAX_PATH] = {0};
                        if (GetCurrentDirectoryW((DWORD)std::size(cwdBuf), cwdBuf)) {
                            std::wstring cwd(cwdBuf);
                            std::wstring logsDir = cwd + L"\\logs";
                            CreateDirectoryW(logsDir.c_str(), NULL);
                            std::wstring outfn = logsDir + L"\\header_paint.txt";
                            HANDLE hf = CreateFileW(outfn.c_str(), GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
                            if (hf != INVALID_HANDLE_VALUE) {
                                std::string towrite = paint_acc + "\r\n";
                                DWORD written = 0;
                                WriteFile(hf, towrite.data(), (DWORD)towrite.size(), &written, NULL);
                                CloseHandle(hf);
                            }
                        }
                    }
                    // exe-dir logs
                    wchar_t modBuf[MAX_PATH] = {0};
                    if (GetModuleFileNameW(NULL, modBuf, (DWORD)std::size(modBuf))) {
                        std::wstring modPath(modBuf);
                        size_t p = modPath.find_last_of(L"\\/");
                        std::wstring exeDir = (p == std::wstring::npos) ? std::wstring(L".") : modPath.substr(0, p);
                        std::wstring logsDir = exeDir + L"\\logs";
                        CreateDirectoryW(logsDir.c_str(), NULL);
                        std::wstring outfn = logsDir + L"\\header_paint.txt";
                        try {
                            std::ofstream ofs2(WideToUtf8(outfn), std::ios::binary | std::ios::trunc);
                            if (ofs2) ofs2 << paint_acc << "\n";
                        } catch(...) {}
                    }
                    // temp folder - write using Win32 API to avoid C++ i/o path encoding issues
                    wchar_t tmpBuf[MAX_PATH] = {0};
                    if (GetTempPathW((DWORD)std::size(tmpBuf), tmpBuf)) {
                        std::wstring tmpdir(tmpBuf);
                        std::wstring outt = tmpdir + L"wup_header_paint.txt";
                        HANDLE hf = CreateFileW(outt.c_str(), GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
                        if (hf != INVALID_HANDLE_VALUE) {
                            std::string towrite = paint_acc + "\r\n";
                            DWORD written = 0;
                            WriteFile(hf, towrite.data(), (DWORD)towrite.size(), &written, NULL);
                            CloseHandle(hf);
                        }
                    }
                    paint_acc.clear();
                    try {
                        // also write an absolute workspace probe for header paint
                        WriteWorkspaceLogW(L"probe_header_paint.txt", paint_acc + "\n");
                    } catch(...) {}
                }
            } catch(...) {}
            x += w;
        }
        ReleaseDC(hwnd, hdc);
        return 0;
    }
    }
    return DefSubclassProc(hwnd, uMsg, wParam, lParam);
}

static void TryForceForegroundWindow(HWND hwnd) {
    if (!hwnd || !IsWindow(hwnd)) return;
    // Try common approaches to bring window to foreground
    ::ShowWindow(hwnd, SW_RESTORE);
    ::BringWindowToTop(hwnd);
    ::SetForegroundWindow(hwnd);
    ::SetActiveWindow(hwnd);
    // Attach thread input to foreground thread as a fallback
    DWORD fgThread = GetWindowThreadProcessId(GetForegroundWindow(), NULL);
    DWORD thisThread = GetCurrentThreadId();
    if (fgThread != 0 && fgThread != thisThread) {
        AttachThreadInput(thisThread, fgThread, TRUE);
        BringWindowToTop(hwnd);
        SetForegroundWindow(hwnd);
        SetActiveWindow(hwnd);
        AttachThreadInput(thisThread, fgThread, FALSE);
    }
}

// Spawn the external probe messagebox program at given coords (non-blocking)
static void SpawnProbeMessageBoxAt(int x, int y, const std::wstring &title, const std::wstring &text) {
    std::wstring exe = L"C:\\Users\\NalleBerg\\Documents\\C++\\Workspace\\WinUpdate\\tools\\msgbox_probe.exe";
    std::wstring cmd = L"\"" + exe + L"\" " + std::to_wstring(x) + L" " + std::to_wstring(y) + L" \"" + title + L"\" \"" + text + L"\"";
    STARTUPINFOW si{}; PROCESS_INFORMATION pi{}; si.cb = sizeof(si);
    bool launched = false;
    DWORD lastErr = 0;
    // Try CreateProcessW first
    if (CreateProcessW(NULL, (LPWSTR)cmd.c_str(), NULL, NULL, FALSE, CREATE_NEW_CONSOLE, NULL, NULL, &si, &pi)) {
        CloseHandle(pi.hThread);
        CloseHandle(pi.hProcess);
        launched = true;
    } else {
        lastErr = GetLastError();
        // Fallback to ShellExecuteW which may succeed in different contexts
        HINSTANCE r = ShellExecuteW(NULL, L"open", exe.c_str(), (LPCWSTR)(std::wstring(std::to_wstring(x)+L" "+std::to_wstring(y))).c_str(), NULL, SW_SHOW);
        if ((INT_PTR)r > 32) launched = true;
        else lastErr = GetLastError();
    }
    try {
        std::string log = "SpawnProbe: exe=" + WideToUtf8(exe) + " launched=" + (launched?"1":"0") + " err=" + std::to_string((int)lastErr) + "\n";
        WriteWorkspaceLogW(L"probe_spawn_log.txt", log);
    } catch(...) {}
}
// subclass procedure for custom-drawn dots control
static LRESULT CALLBACK DotsSubclassProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam,
    UINT_PTR uIdSubclass, DWORD_PTR dwRefData) {
    switch (uMsg) {
    case WM_PAINT: {
        PAINTSTRUCT ps;
        HDC hdc = BeginPaint(hwnd, &ps);
        RECT rc; GetClientRect(hwnd, &rc);
        // fill background with dialog face
        HBRUSH hbr = GetSysColorBrush(COLOR_BTNFACE);
        FillRect(hdc, &rc, hbr);
        // determine number of dots from global animation state
        int state = g_loading_anim_state % 3;
        int count = (state == 0) ? 1 : (state == 1) ? 3 : 5;
        // compute diameter and spacing (smaller, more compact)
        int ch = rc.bottom - rc.top;
        int dia = std::min(12, std::max(6, ch - 12));
        int gap = dia / 2; // tighter spacing
        int totalW = count * dia + (count - 1) * gap;
        int startX = rc.left + ((rc.right - rc.left) - totalW) / 2;
        int y = rc.top + (rc.bottom - rc.top - dia) / 2;
        // paint filled navy circles (select pen+brush)
        HPEN hPen = CreatePen(PS_SOLID, 1, RGB(0,0,128));
        HBRUSH hBrush = CreateSolidBrush(RGB(0,0,128));
        HGDIOBJ oldPen = SelectObject(hdc, hPen);
        HGDIOBJ oldBrush = SelectObject(hdc, hBrush);
        for (int i = 0; i < count; ++i) {
            int x = startX + i * (dia + gap);
            Ellipse(hdc, x, y, x + dia, y + dia);
        }
        SelectObject(hdc, oldPen);
        SelectObject(hdc, oldBrush);
        DeleteObject(hPen);
        DeleteObject(hBrush);
        EndPaint(hwnd, &ps);
        return 0;
    }
    case WM_DESTROY:
        RemoveWindowSubclass(hwnd, DotsSubclassProc, uIdSubclass);
        break;
    }
    return DefSubclassProc(hwnd, uMsg, wParam, lParam);
}
static void EnsurePopupClassRegistered(HINSTANCE hInst) {
    if (g_popupClassRegistered) return;
    WNDCLASSEXW wc{};
    wc.cbSize = sizeof(wc);
    wc.style = CS_HREDRAW | CS_VREDRAW;
    wc.lpfnWndProc = PopupWndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = hInst;
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_BTNFACE + 1);
    wc.lpszClassName = L"WUPopupClass";
    RegisterClassExW(&wc);
    g_popupClassRegistered = true;
}

static LRESULT CALLBACK PopupWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
    switch (uMsg) {
    case WM_CREATE: {
        // Diagnostic: record that WM_CREATE executed (workspace logs)
        try {
            std::wstring out = L"logs\\wm_create.txt";
            wchar_t cwdBuf[MAX_PATH] = {0};
            GetCurrentDirectoryW((DWORD)std::size(cwdBuf), cwdBuf);
            std::wstring cwd(cwdBuf);
            std::wstring fn = cwd + L"\\" + out;
            HANDLE hf = CreateFileW(fn.c_str(), GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
            if (hf != INVALID_HANDLE_VALUE) {
                std::string s = "WM_CREATE executed PID=" + std::to_string(GetCurrentProcessId()) + "\n";
                DWORD w = 0; WriteFile(hf, s.data(), (DWORD)s.size(), &w, NULL); CloseHandle(hf);
            }
            // also append to the verbose log so it's visible in the editor
            std::ofstream vdbg("logs/wup_ui_setitems_verbose.txt", std::ios::binary | std::ios::app);
            if (vdbg) { vdbg << "WM_CREATE PID=" << GetCurrentProcessId() << " TS=" << WideToUtf8(GetTimestampNow()) << "\n"; vdbg.close(); }
        } catch(...) {}
        
        // start animation timer on popup (175ms per user preference)
        g_loading_anim_state = 0;
        SetTimer(hwnd, LOADING_TIMER_ID, 175, NULL);
        return 0;
    }
    case WM_TIMER: {
        if (wParam == LOADING_TIMER_ID) {
            g_loading_anim_state = (g_loading_anim_state + 1) % 3; // cycle 0..2
            InvalidateRect(hwnd, NULL, TRUE); // full repaint (double-buffered)
        }
        return 0;
    }
    case WM_PAINT: {
        PAINTSTRUCT ps;
        HDC hdc = BeginPaint(hwnd, &ps);
        RECT rc; GetClientRect(hwnd, &rc);
        int w = rc.right - rc.left;
        int h = rc.bottom - rc.top;

        // double-buffering
        HDC hdcMem = CreateCompatibleDC(hdc);
        HBITMAP hbm = CreateCompatibleBitmap(hdc, w, h);
        HGDIOBJ oldBmp = SelectObject(hdcMem, hbm);

        // fill background with dialog face color
        HBRUSH hbrFace = GetSysColorBrush(COLOR_BTNFACE);
        FillRect(hdcMem, &rc, hbrFace);

        // draw a simple frame to mimic dialog border
        HBRUSH hbrFrame = GetSysColorBrush(COLOR_WINDOWFRAME);
        RECT fr = rc;
        FrameRect(hdcMem, &fr, hbrFrame);

        // layout: left icon cell, right title/desc cell (row1); row2 merged for dots
        int padding = 12;
        int iconW = 48; int iconH = 48;
        int ix = padding;
        int iy = padding;
        // draw information icon using standard system icon
        HICON hInfo = LoadIcon(NULL, IDI_INFORMATION);
        if (hInfo) DrawIconEx(hdcMem, ix, iy, hInfo, iconW, iconH, 0, NULL, DI_NORMAL);

        int txtX = ix + iconW + padding;
        int txtW = w - txtX - padding;
        int row1Height = iconH + padding; // provide vertical space for icon + text
        // Title (big)
        RECT titleRect = { txtX, iy, txtX + txtW, iy + row1Height / 2 };
        // Description under title within first row
        RECT descRect = { txtX, iy + row1Height / 2, txtX + txtW, iy + row1Height };

        // draw title using existing title font if available (preserves ClearType)
        if (g_hTitleFont) {
            HGDIOBJ oldFont = SelectObject(hdcMem, g_hTitleFont);
            SetTextColor(hdcMem, RGB(0,0,0));
            SetBkMode(hdcMem, TRANSPARENT);
            DrawTextW(hdcMem, t("loading_title").c_str(), -1, &titleRect, DT_LEFT | DT_SINGLELINE | DT_VCENTER);
            SelectObject(hdcMem, oldFont);
        } else {
            SetTextColor(hdcMem, RGB(0,0,0));
            SetBkMode(hdcMem, TRANSPARENT);
            DrawTextW(hdcMem, t("loading_title").c_str(), -1, &titleRect, DT_LEFT | DT_SINGLELINE | DT_VCENTER);
        }

        // draw description smaller
        if (g_hLastUpdatedFont) {
            HGDIOBJ oldFont = SelectObject(hdcMem, g_hLastUpdatedFont);
            SetTextColor(hdcMem, RGB(64,64,64));
            SetBkMode(hdcMem, TRANSPARENT);
            DrawTextW(hdcMem, t("loading_desc").c_str(), -1, &descRect, DT_LEFT | DT_SINGLELINE | DT_VCENTER);
            SelectObject(hdcMem, oldFont);
        } else {
            SetTextColor(hdcMem, RGB(64,64,64));
            SetBkMode(hdcMem, TRANSPARENT);
            DrawTextW(hdcMem, t("loading_desc").c_str(), -1, &descRect, DT_LEFT | DT_SINGLELINE | DT_VCENTER);
        }

        // Row2: center dots across full width (merged cell)
        int row2Top = iy + row1Height + padding/2;
        int row2H = h - row2Top - padding;
        RECT dotsArea = { rc.left + padding, row2Top, rc.right - padding, row2Top + row2H };

        int state = g_loading_anim_state % 3;
        int count = (state == 0) ? 1 : (state == 1) ? 3 : 5;
        int dia = std::min(14, std::max(6, row2H - 8));
        int gap = dia / 2;
        int totalW = count * dia + (count - 1) * gap;
        int centerX = (dotsArea.left + dotsArea.right) / 2;
        int startX = centerX - totalW / 2;
        int y = dotsArea.top + (row2H - dia) / 2;

        // draw navy filled circles
        HPEN hPen = CreatePen(PS_SOLID, 1, RGB(0,0,128));
        HBRUSH hBrush = CreateSolidBrush(RGB(0,0,128));
        HGDIOBJ oldPen = SelectObject(hdcMem, hPen);
        HGDIOBJ oldBrush = SelectObject(hdcMem, hBrush);
        for (int i = 0; i < count; ++i) {
            int x = startX + i * (dia + gap);
            Ellipse(hdcMem, x, y, x + dia, y + dia);
        }
        SelectObject(hdcMem, oldPen);
        SelectObject(hdcMem, oldBrush);
        DeleteObject(hPen);
        DeleteObject(hBrush);

        // blit buffer to screen
        BitBlt(hdc, 0, 0, w, h, hdcMem, 0, 0, SRCCOPY);

        // cleanup
        SelectObject(hdcMem, oldBmp);
        DeleteObject(hbm);
        DeleteDC(hdcMem);
        EndPaint(hwnd, &ps);
        return 0;
    }
    case WM_DESTROY:
        KillTimer(hwnd, LOADING_TIMER_ID);
        return 0;
    default:
        return DefWindowProcW(hwnd, uMsg, wParam, lParam);
    }
    return DefWindowProcW(hwnd, uMsg, wParam, lParam);
}
static LRESULT CALLBACK AnimSubclassProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam,
    UINT_PTR uIdSubclass, DWORD_PTR dwRefData) {
    switch (uMsg) {
    case WM_TIMER: {
        g_install_anim_state++;
        InvalidateRect(hwnd, NULL, TRUE);
        return 0;
    }
    case WM_PAINT: {
        PAINTSTRUCT ps;
        HDC hdc = BeginPaint(hwnd, &ps);
        RECT rc; GetClientRect(hwnd, &rc);
        // clear background
        HBRUSH hbr = GetSysColorBrush(COLOR_BTNFACE);
        FillRect(hdc, &rc, hbr);
        int w = rc.right - rc.left;
        int h = rc.bottom - rc.top;
        int dots = 5;
        int dotW = std::max(6, h - 6);
        int spacing = std::max(8, (w - dots * dotW) / (dots + 1));
        int totalCycle = spacing + dotW;
        int offset = (g_install_anim_state % (w + totalCycle));
        HBRUSH fill = CreateSolidBrush(RGB(0, 102, 204));
        HBRUSH old = (HBRUSH)SelectObject(hdc, fill);
        for (int i = 0; i < dots; ++i) {
            int x = (offset + i * (dotW + spacing)) % (w - dotW);
            RECT r = { rc.left + x, rc.top + 2, rc.left + x + dotW, rc.top + 2 + dotW };
            RoundRect(hdc, r.left, r.top, r.right, r.bottom, 4, 4);
        }
        SelectObject(hdc, old);
        DeleteObject(fill);
        EndPaint(hwnd, &ps);
        return 0;
    }
    case WM_NCDESTROY:
        RemoveWindowSubclass(hwnd, AnimSubclassProc, uIdSubclass);
        break;
    }
    return DefSubclassProc(hwnd, uMsg, wParam, lParam);
}


// Run a command, capture stdout/stderr to a temp file, return exit code and UTF-8 output.
static std::pair<int,std::string> RunProcessCaptureExitCode(const std::wstring &cmd, int timeoutMs) {
    // Launch the given command line and capture stdout+stderr via pipes (no temp files).
    std::pair<int,std::string> result = {-1, std::string()};
    SECURITY_ATTRIBUTES sa{}; sa.nLength = sizeof(sa); sa.bInheritHandle = TRUE; sa.lpSecurityDescriptor = NULL;
    HANDLE hRead = NULL, hWrite = NULL;
    if (!CreatePipe(&hRead, &hWrite, &sa, 0)) return result;
    // ensure read handle is not inherited
    SetHandleInformation(hRead, HANDLE_FLAG_INHERIT, 0);

    STARTUPINFOW si{}; si.cb = sizeof(si);
    si.dwFlags |= STARTF_USESTDHANDLES;
    si.hStdOutput = hWrite;
    si.hStdError = hWrite;
    si.hStdInput = NULL;

    PROCESS_INFORMATION pi{};
    // copy command into writable buffer for CreateProcess
    std::wstring cmdCopy = cmd;
    BOOL ok = CreateProcessW(NULL, &cmdCopy[0], NULL, NULL, TRUE, CREATE_NO_WINDOW, NULL, NULL, &si, &pi);
    // close write end in parent regardless
    CloseHandle(hWrite);
    if (!ok) {
        CloseHandle(hRead);
        return result;
    }

    DWORD wait = WaitForSingleObject(pi.hProcess, timeoutMs > 0 ? (DWORD)timeoutMs : INFINITE);
    if (wait == WAIT_TIMEOUT) {
        TerminateProcess(pi.hProcess, 1);
        result.first = -2; // timeout sentinel
    } else {
        DWORD exitCode = 0; GetExitCodeProcess(pi.hProcess, &exitCode); result.first = (int)exitCode;
    }

    // read all available output from pipe
    std::string output;
    const DWORD bufSize = 4096;
    char buffer[bufSize];
    DWORD read = 0;
    while (ReadFile(hRead, buffer, bufSize, &read, NULL) && read > 0) {
        output.append(buffer, buffer + read);
    }

    CloseHandle(hRead);
    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);

    // append to run log for debugging
    try {
        std::ofstream lof("wup_run_log.txt", std::ios::app | std::ios::binary);
        if (lof) {
            std::string ncmd = WideToUtf8(cmd);
            lof << "--- CMD: " << ncmd << " ---\n";
            lof << "Exit: " << result.first << "\n";
            if (result.first == -2) lof << "(TIMEOUT)\n";
            lof << "Output:\n" << output << "\n\n";
        }
    } catch(...) {}

    result.second = output;
    return result;
}

static std::string WideToUtf8(const std::wstring &w) {
    if (w.empty()) return {};
    int size = WideCharToMultiByte(CP_UTF8, 0, w.data(), (int)w.size(), NULL, 0, NULL, NULL);
    if (size <= 0) return std::string();
    std::string out(size, 0);
    WideCharToMultiByte(CP_UTF8, 0, w.data(), (int)w.size(), &out[0], size, NULL, NULL);
    return out;
}

static std::wstring Utf8ToWide(const std::string &s) {
    if (s.empty()) return {};
    int wideLen = MultiByteToWideChar(CP_UTF8, 0, s.data(), (int)s.size(), NULL, 0);
    if (wideLen <= 0) return std::wstring(s.begin(), s.end());
    std::wstring out(wideLen, 0);
    MultiByteToWideChar(CP_UTF8, 0, s.data(), (int)s.size(), &out[0], wideLen);
    return out;
}

static std::string ReadFileUtf8(const std::wstring &path) {
    std::string narrow = WideToUtf8(path);
    std::ifstream ifs(narrow, std::ios::binary);
    if (!ifs) return std::string();
    std::ostringstream ss;
    ss << ifs.rdbuf();
    return ss.str();
}

static std::wstring GetTimestampNow() {
    SYSTEMTIME st;
    GetLocalTime(&st);
    wchar_t buf[64];
    swprintf(buf, _countof(buf), L"%04d-%02d-%02d %02d:%02d:%02d", st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond);
    return std::wstring(buf);
}

static void UpdateLastUpdatedLabel(HWND hwnd) {
    if (!g_hLastUpdated) return;
    std::wstring ts = GetTimestampNow();
    std::wstring prefix = t("list_last_updated_prefix");
    std::wstring txt = prefix + L" " + ts;
    SetWindowTextW(g_hLastUpdated, txt.c_str());
}

static void ShowLoading(HWND parent) {
    if (!parent) return;
    if (g_hLoadingPopup && IsWindow(g_hLoadingPopup)) return;
    RECT rc;
    GetWindowRect(parent, &rc);
    int pw = rc.right - rc.left;
    int ph = rc.bottom - rc.top;
    int w = 260; int h = 110;
    int x = rc.left + (pw - w) / 2;
    int y = rc.top + (ph - h) / 2;
    // Create a popup window that looks like an informational dialog
    // Create an owned border-style popup (no title or close button)
    HINSTANCE hInst = GetModuleHandleW(NULL);
    // ensure our popup window class is registered and create a top-level border popup
    EnsurePopupClassRegistered(hInst);
    // create a top-level border popup (no caption/title bar) positioned centered over parent
    g_hLoadingPopup = CreateWindowExW(WS_EX_TOOLWINDOW | WS_EX_TOPMOST, L"WUPopupClass", NULL,
        WS_POPUP | WS_BORDER | WS_VISIBLE, x, y, w, h, NULL, NULL, hInst, NULL);
    if (g_hLoadingPopup) {
        // Owner-drawn popup: the window procedure paints icon, title/desc and centered dots.
        ShowWindow(g_hLoadingPopup, SW_SHOW);
        UpdateWindow(g_hLoadingPopup);
        // WM_CREATE handler of the popup will start the 175ms timer.
    }
}

static void HideLoading() {
    if (g_hLoadingPopup && IsWindow(g_hLoadingPopup)) {
        DestroyWindow(g_hLoadingPopup);
        g_hLoadingPopup = NULL;
        g_hLoadingIcon = NULL;
        g_hLoadingText = NULL;
        g_hLoadingDesc = NULL;
        g_hLoadingDots = NULL;
    }
}

// Query the system for the installed version of a package by id using `winget list`.
// (No per-id installed-version helper in this restore)

static std::string RunWingetElevatedCaptureJson(HWND hwnd) {
    wchar_t tmpPathBuf[MAX_PATH];
    GetTempPathW(MAX_PATH, tmpPathBuf);
    unsigned long long uniq = GetTickCount64();
    std::wstring batch = std::wstring(tmpPathBuf) + L"winget_run_" + std::to_wstring(uniq) + L".bat";
    std::wstring outfn = std::wstring(tmpPathBuf) + L"winget_out_" + std::to_wstring(uniq) + L".txt";
    // write batch that redirects output to outfn
    std::string nbatch = WideToUtf8(batch);
    std::string nout = WideToUtf8(outfn);
    std::ofstream ofs(nbatch, std::ios::binary);
    ofs << "@echo off\r\n";
    ofs << "winget upgrade --accept-source-agreements --accept-package-agreements > \"" << nout << "\" 2>&1\r\n";
    ofs.close();

    SHELLEXECUTEINFOW sei{};
    sei.cbSize = sizeof(sei);
    sei.fMask = SEE_MASK_NOCLOSEPROCESS;
    sei.hwnd = hwnd;
    sei.lpVerb = L"runas";
    sei.lpFile = L"cmd.exe";
    std::wstring params = L"/C \"" + batch + L"\"";
    sei.lpParameters = params.c_str();
    sei.nShow = SW_HIDE; // hide elevated console window
    if (!ShellExecuteExW(&sei)) {
        return std::string();
    }
    DWORD wait = WaitForSingleObject(sei.hProcess, 15000); // 15s timeout for elevated capture
    if (wait == WAIT_TIMEOUT) {
        TerminateProcess(sei.hProcess, 1);
    }
    CloseHandle(sei.hProcess);
    std::string out = ReadFileUtf8(outfn);
    // cleanup temp files
    DeleteFileW(batch.c_str());
    DeleteFileW(outfn.c_str());
    return out;
}

// very small JSON-ish extractor for "Id" and "Name" values from winget --output json
// Winget's JSON is unreliable; treat incoming JSON-like text as raw/table output
static void ParseWingetJsonForPackages(const std::string &jsonText) {
    // Forward to the robust raw/text parser so we only work from table/raw output
    ParseWingetTextForPackages(jsonText);
}

// Remove any entries in g_packages that are skipped according to the configured map.
static void RemoveSkippedFromPackages() {
    try {
        AppendLog(std::string("RemoveSkippedFromPackages: start, count=") + std::to_string(g_packages.size()) + "\n");
    } catch(...) {}
    std::vector<std::pair<std::string,std::string>> kept;
    kept.reserve(g_packages.size());
    for (auto &p : g_packages) {
        bool skip = false;
        try {
            // try to find available version from last known map
            std::string avail;
            {
                std::lock_guard<std::mutex> lk(g_versions_mutex);
                auto it = g_last_avail_versions.find(p.first);
                if (it != g_last_avail_versions.end()) avail = it->second;
            }
            if (IsSkipped(p.first, avail)) {
                skip = true;
                try { AppendLog(std::string("RemoveSkippedFromPackages: skipping ") + p.first + " avail='" + avail + "' name='" + p.second + "'\n"); } catch(...) {}
            }
        } catch(...) { /* on error, do not skip */ }
        if (!skip) kept.push_back(p);
    }
    g_packages.swap(kept);
    try { AppendLog(std::string("RemoveSkippedFromPackages: end, kept=") + std::to_string(g_packages.size()) + "\n"); } catch(...) {}
}
}

// Parse human-readable `winget upgrade` text output.
// compare semantic-ish version strings: returns -1 if a<b, 0 if equal, 1 if a>b
static int CompareVersions(const std::string &a, const std::string &b) {
    if (a == b) return 0;
    std::istringstream sa(a), sb(b);
    std::string ta, tb;
    while (true) {
        if (!std::getline(sa, ta, '.')) ta.clear();
        if (!std::getline(sb, tb, '.')) tb.clear();
        if (ta.empty() && tb.empty()) break;
        // try numeric compare
        long va = 0, vb = 0;
        try { va = std::stol(ta.empty()?"0":ta); } catch(...) { va = 0; }
        try { vb = std::stol(tb.empty()?"0":tb); } catch(...) { vb = 0; }
        if (va < vb) return -1;
        if (va > vb) return 1;
        // continue
        if (!sa.good() && !sb.good()) break;
    }
    return 0;
}

// Parsing implementations are centralized in src/parsing.cpp; use those.

static std::vector<std::pair<std::string,std::string>> ExtractIdsFromNameIdText(const std::string &text) {
    std::vector<std::pair<std::string,std::string>> ids;
    std::istringstream iss(text);
    std::string ln;
    auto trim = [](std::string s){ while(!s.empty() && isspace((unsigned char)s.front())) s.erase(s.begin()); while(!s.empty() && isspace((unsigned char)s.back())) s.pop_back(); return s; };
    while (std::getline(iss, ln)) {
        std::string t = trim(ln);
        if (t.empty()) continue;
        // skip header/separator lines that contain dashes or 'Name' header
        if (t.find("----") != std::string::npos) continue;
        if (t.find("Name") != std::string::npos && t.find("Id") != std::string::npos) continue;
        std::istringstream ls(t);
        std::vector<std::string> toks;
        std::string tok;
        while (ls >> tok) toks.push_back(tok);
        if (toks.size() >= 2) {
            std::string id = toks.back();
            std::string name;
            for (size_t i = 0; i + 1 < toks.size(); ++i) {
                if (i) name += " ";
                name += toks[i];
            }
            ids.emplace_back(id, name);
        }
    }
    return ids;
}

static void CheckIdsForUpdates(const std::vector<std::pair<std::string,std::string>> &candidates, std::set<std::pair<std::string,std::string>> &outFound, HWND hwnd) {
    // Probe all candidate ids in parallel with limited concurrency to keep it fast.
    unsigned int hw = std::thread::hardware_concurrency();
    size_t concurrency = hw > 0 ? std::min<unsigned int>(hw, 8) : 4;
    std::vector<std::future<std::pair<std::string,std::string>>> futures;
    futures.reserve(candidates.size());

    auto probeOne = [](const std::pair<std::string,std::string> &p)->std::pair<std::string,std::string> {
        std::wstring idw(p.first.begin(), p.first.end());
        std::wstring cmd = L"cmd /C winget upgrade --id \"" + idw + L"\" --accept-source-agreements --accept-package-agreements";
        auto res = RunProcessCaptureExitCode(cmd, 4000);
        std::string out = res.second;
        if (out.empty()) {
            res = RunProcessCaptureExitCode(cmd, 8000);
            out = res.second;
        }
        if (!out.empty()) {
            std::set<std::pair<std::string,std::string>> found;
            ExtractUpdatesFromText(out, found);
            for (auto &f : found) {
                if (f.first == p.first) return f; // return matching id/name
            }
        }
        return std::pair<std::string,std::string>();
    };

    size_t idx = 0;
    while (idx < candidates.size()) {
        // launch up to concurrency tasks
        size_t launched = 0;
        std::vector<std::future<std::pair<std::string,std::string>>> batch;
        for (; idx < candidates.size() && launched < concurrency; ++idx, ++launched) {
            batch.push_back(std::async(std::launch::async, probeOne, candidates[idx]));
        }
        // collect results
        for (auto &f : batch) {
            try {
                auto r = f.get();
                if (!r.first.empty()) outFound.emplace(r.first, r.second);
            } catch(...) {}
        }
        // small pause to avoid hammering winget
        std::this_thread::sleep_for(std::chrono::milliseconds(50));
    }
}

// Read the most recent raw winget output file matching prefix wup_winget_raw_*.txt
static std::string ReadMostRecentRawWinget() {
    namespace fs = std::filesystem;
    std::string best;
    std::filesystem::file_time_type bestTime = std::filesystem::file_time_type::min();
    try {
        for (auto &p : fs::directory_iterator(fs::current_path())) {
            std::string name = p.path().filename().string();
            if (name.rfind("wup_winget_raw_", 0) == 0 && p.path().extension() == ".txt") {
                auto ftime = fs::last_write_time(p.path());
                if (ftime > bestTime) {
                    bestTime = ftime;
                    best = p.path().string();
                }
            }
        }
        if (!best.empty()) {
            // read file
            std::ifstream ifs(best, std::ios::binary);
            if (ifs) {
                std::ostringstream ss; ss << ifs.rdbuf();
                return ss.str();
            }
        }
    } catch(...) {}
    return std::string();
}

static void ParseWingetTextForPackages(const std::string &text) {
    g_packages.clear();
    std::istringstream iss(text);
    std::vector<std::string> lines;
    std::string line;
    while (std::getline(iss, line)) {
        // trim CR
        while (!line.empty() && (line.back()=='\r' || line.back()=='\n')) line.pop_back();
        // keep even empty lines (we'll skip later)
        lines.push_back(line);
    }
    if (lines.empty()) return;

    // find header line (contains Name and Id) and separator (----)
    int headerIdx = -1;
    int sepIdx = -1;
    for (int i = 0; i < (int)lines.size(); ++i) {
        if (lines[i].find("----") != std::string::npos) {
            sepIdx = i;
            break;
        }
    }
    if (sepIdx <= 0) return;
    headerIdx = sepIdx - 1;
    std::string header = lines[headerIdx];

    auto trim = [](std::string s){ while(!s.empty() && isspace((unsigned char)s.front())) s.erase(s.begin()); while(!s.empty() && isspace((unsigned char)s.back())) s.pop_back(); return s; };

    // determine column start positions from header
    std::vector<int> colStarts;
    std::vector<std::string> colNames = {"Name","Id","Version","Available","Source"};
    for (auto &cn : colNames) {
        size_t p = header.find(cn);
        if (p != std::string::npos) colStarts.push_back((int)p);
    }
    if (colStarts.size() < 2) {
        // fallback: whitespace token parsing
        for (int i = sepIdx + 1, lastAdded = -1; i < (int)lines.size(); ++i) {
            const std::string &ln = lines[i];
            if (ln.find("upgrades available") != std::string::npos) break;
            if (trim(ln).empty()) continue;
            std::istringstream ls(ln);
            std::vector<std::string> toks;
            std::string tok;
            while (ls >> tok) toks.push_back(tok);
            if (toks.size() < 4) continue;
                // Look for pattern: <name...> <id> <installed-version> <available-version>
                std::regex verRe2(R"(^[0-9]+(\.[0-9]+)*$)");
                size_t n = toks.size();
                // require at least two trailing version-like tokens
                if (n >= 3 && std::regex_match(toks[n-1], verRe2) && std::regex_match(toks[n-2], verRe2)) {
                    std::string available = toks[n-1];
                    std::string installed = toks[n-2];
                    std::string id = toks[n-3];
                    std::string name;
                    for (size_t j = 0; j + 3 < toks.size(); ++j) {
                        if (j) name += " ";
                        name += toks[j];
                    }
                    if (name.empty()) name = id;
                    if (CompareVersions(installed, available) < 0) g_packages.emplace_back(id, name);
                } else {
                    // fallback: if we can't detect versions, skip to avoid false positives
                    continue;
                }
            lastAdded = (int)g_packages.size()-1;
        }
        return;
    }

    // add end position as line length sentinel per line when slicing
    int lastAdded = -1;
    for (int i = sepIdx + 1; i < (int)lines.size(); ++i) {
        const std::string &ln = lines[i];
        if (ln.find("upgrades available") != std::string::npos) break;
        if (trim(ln).empty()) continue;
        // if the line is shorter than second column start, treat as continuation
        if ((int)ln.size() <= colStarts[1]) {
            if (lastAdded >= 0) {
                std::string cont = trim(ln);
                if (!cont.empty()) {
                    g_packages[lastAdded].second += " ";
                    g_packages[lastAdded].second += cont;
                }
            }
            continue;
        }
        auto substrSafe = [&](const std::string &s, int a, int b)->std::string{
            int len = (int)s.size();
            if (a >= len) return std::string();
            int end = std::min(len, b);
            return s.substr(a, end - a);
        };

        // compute per-column substrings using next column start or line end
        int ncols = (int)colStarts.size();
        std::vector<std::string> fields(ncols);
        for (int c = 0; c < ncols; ++c) {
            int a = colStarts[c];
            int b = (c+1 < ncols) ? colStarts[c+1] : (int)ln.size();
            fields[c] = trim(substrSafe(ln, a, b));
        }
        std::string name = fields[0];
        std::string id = (ncols > 1) ? fields[1] : std::string();
        if (id.empty()) {
            // treat as continuation if id missing
            if (lastAdded >= 0) {
                std::string cont = trim(ln);
                if (!cont.empty()) {
                    g_packages[lastAdded].second += " ";
                    g_packages[lastAdded].second += cont;
                }
            }
            continue;
        }
        if (name.empty()) name = id;
        // If available column present, use it to filter skipped entries immediately
        try {
            std::string availCol = (ncols > 3) ? fields[3] : std::string();
            if (!IsSkipped(id, availCol)) g_packages.emplace_back(id, name);
        } catch(...) {
            g_packages.emplace_back(id, name);
        }
        lastAdded = (int)g_packages.size()-1;
    }

    // Additional heuristic pass: look for tokens like <Id-with-dot> <version>
    // to catch lines where wrapping confused column slicing.
    std::set<std::string> seenIds;
    for (auto &p : g_packages) seenIds.insert(p.first);
    std::regex verRe(R"(^[0-9]+(\.[0-9]+)*$)");
    for (const auto &ln : lines) {
        std::istringstream ls(ln);
        std::vector<std::string> toks;
        std::string tok;
        while (ls >> tok) toks.push_back(tok);
        // look for pattern: ... <id> <installed> <available>
        for (size_t j = 0; j + 2 < toks.size(); ++j) {
            if (std::regex_match(toks[j+1], verRe) && std::regex_match(toks[j+2], verRe)) {
                std::string id = toks[j];
                if (seenIds.count(id)) break;
                std::string installed = toks[j+1];
                std::string available = toks[j+2];
                if (CompareVersions(installed, available) < 0) {
                    std::string name;
                    for (size_t k = 0; k < j; ++k) {
                        if (k) name += " ";
                        name += toks[k];
                    }
                    if (name.empty()) name = id;
                    try {
                        if (!IsSkipped(id, available)) { g_packages.emplace_back(id, name); seenIds.insert(id); }
                    } catch(...) { g_packages.emplace_back(id, name); seenIds.insert(id); }
                }
                break;
            }
        }
    }
    }

static void PopulateListView(HWND hList) {
    // Log that PopulateListView started (do not create workspace files)
    try { AppendLog(std::string("PopulateListView: PID=") + std::to_string(GetCurrentProcessId()) + " TID=" + std::to_string(GetCurrentThreadId()) + "\n"); } catch(...) {}

    // Diagnostic dump: log current skipped map, available versions, and package summary
    try {
        AppendLog("PopulateListView: diagnostic dump start\n");
        try {
            AppendLog(std::string("PopulateListView: g_packages size=") + std::to_string((int)g_packages.size()) + "\n");
        } catch(...) {}
        try {
            auto m = GetAvailableVersionsCached();
            AppendLog(std::string("PopulateListView: avail_map size=") + std::to_string((int)m.size()) + "\n");
            for (auto &p : m) { AppendLog(std::string("avail: '") + p.first + "' -> '" + p.second + "'\n"); }
        } catch(...) { AppendLog("PopulateListView: failed to get avail map\n"); }
        try {
            std::map<std::string,std::string> copy;
            // build copy of in-memory skipped map
            {
                std::lock_guard<std::mutex> lk(g_packages_mutex);
                for (auto &kv : g_skipped_versions) copy[kv.first] = kv.second;
            }
            AppendLog(std::string("PopulateListView: in-memory skipped size=") + std::to_string((int)copy.size()) + "\n");
            for (auto &kv : copy) AppendLog(std::string("skipped: '") + kv.first + "' -> '" + kv.second + "'\n");
        } catch(...) { AppendLog("PopulateListView: failed to dump skipped map\n"); }
        AppendLog("PopulateListView: diagnostic dump end\n");
    } catch(...) {}

    // Ensure any parsed-but-skipped packages are removed before inserting into the ListView
    try { RemoveSkippedFromPackages(); } catch(...) {}

    ListView_DeleteAllItems(hList);
    LVITEMW lvi{};
    lvi.mask = LVIF_TEXT | LVIF_PARAM;
    // prepare maps for versions (prefer cached probes to avoid blocking UI twice)
    auto avail = GetAvailableVersionsCached();
    auto inst = GetInstalledVersionsCached();
    for (int i = 0; i < (int)g_packages.size(); ++i) {
        std::string name = g_packages[i].second;
        std::string id = g_packages[i].first;
        // If this package is explicitly skipped (id + available version), do not add to the list.
        try {
            auto avail_map = GetAvailableVersionsCached();
            std::string availStr;
            auto ait = avail_map.find(id);
            std::string checkId = id;
            if (ait != avail_map.end()) availStr = ait->second;
            else {
                // try resolving display name to canonical id
                std::string resolved = ResolveIdForName(id);
                if (!resolved.empty()) {
                    checkId = resolved;
                    auto ait2 = avail_map.find(resolved);
                    if (ait2 != avail_map.end()) availStr = ait2->second;
                }
            }
            if (!availStr.empty()) {
                try {
                    AppendLog(std::string("PopulateListView: checking skip for id='") + checkId + "' avail='" + availStr + "' (orig='" + id + "')\n");
                    bool skipped = false;
                    try { skipped = IsSkipped(checkId, availStr); } catch(...) { skipped = false; }
                    AppendLog(std::string("PopulateListView: IsSkipped returned ") + (skipped?"true":"false") + std::string(" for id='") + checkId + "' avail='" + availStr + "'\n");
                    if (skipped) continue;
                } catch(...) {}
            } else {
                // fallback: check last-known available map as a further defensive check
                try {
                    auto fallback = GetAvailableVersionsCached();
                    auto fit = fallback.find(id);
                    if (fit != fallback.end()) {
                        AppendLog(std::string("PopulateListView: fallback check for id='") + id + "' avail='" + fit->second + "'\n");
                        bool skipped = false;
                        try { skipped = IsSkipped(id, fit->second); } catch(...) { skipped = false; }
                        AppendLog(std::string("PopulateListView: fallback IsSkipped returned ") + (skipped?"true":"false") + std::string(" for id='") + id + "' avail='" + fit->second + "'\n");
                        if (skipped) continue;
                    }
                } catch(...) {}
            }
        } catch(...) {}
        std::wstring wname = Utf8ToWide(name);
        std::wstring wid = Utf8ToWide(id);
        lvi.iItem = i;
        lvi.iSubItem = 0;
        lvi.pszText = (LPWSTR)wname.c_str();
        lvi.lParam = i;
        SendMessageW(hList, LVM_INSERTITEMW, 0, (LPARAM)&lvi);
        // Current version (subitem 1)
        LVITEMW lviCur{}; lviCur.mask = LVIF_TEXT; lviCur.iItem = i; lviCur.iSubItem = 1;
        std::wstring wcur = L"";
        auto fit = inst.find(id);
        if (fit != inst.end()) wcur = Utf8ToWide(fit->second);
        lviCur.pszText = (LPWSTR)wcur.c_str();
        SendMessageW(hList, LVM_SETITEMW, 0, (LPARAM)&lviCur);
        // Available version (subitem 2)
        LVITEMW lviAvail{}; lviAvail.mask = LVIF_TEXT; lviAvail.iItem = i; lviAvail.iSubItem = 2;
        std::wstring wavail = L"";
        auto ait = avail.find(id);
        if (ait != avail.end()) wavail = Utf8ToWide(ait->second);
        lviAvail.pszText = (LPWSTR)wavail.c_str();
        SendMessageW(hList, LVM_SETITEMW, 0, (LPARAM)&lviAvail);
        // Skip column (subitem 3): show localized Skip label if present
        LVITEMW lviSkip{}; lviSkip.mask = LVIF_TEXT; lviSkip.iItem = i; lviSkip.iSubItem = 3;
        std::wstring skipText = L"";
        {
            std::lock_guard<std::mutex> lk(g_packages_mutex);
            auto it = g_skipped_versions.find(id);
            if (it != g_skipped_versions.end()) skipText = t("skip_col");
            else {
                // try resolving id/display-name to canonical id and check skipped map
                try {
                    std::string resolved = ResolveIdForName(id);
                    if (!resolved.empty()) {
                        auto it2 = g_skipped_versions.find(resolved);
                        if (it2 != g_skipped_versions.end()) skipText = t("skip_col");
                    }
                } catch(...) {}
            }
        }
        lviSkip.pszText = (LPWSTR)skipText.c_str();
        // If the item is marked skipped in the per-user INI and the "Show skipped" checkbox
        // is not checked, then omit the row from the list (so skipped updates aren't shown).
        bool showSkippedChecked = false;
        HWND parentWnd = GetAncestor(hList, GA_ROOT);
        if (parentWnd) {
            HWND hChk = GetDlgItem(parentWnd, IDC_CHECK_SHOW_SKIPPED);
            if (hChk) showSkippedChecked = (SendMessageW(hChk, BM_GETCHECK, 0, 0) == BST_CHECKED);
        }
        bool isSkippedEntry = false;
        try {
            std::string availStr = "";
            if (ait != avail.end()) availStr = ait->second;
            // first try direct id
            if (IsSkipped(id, availStr)) isSkippedEntry = true;
            else {
                // fallback: resolve id/display-name to canonical id and check
                std::string resolved = ResolveIdForName(id);
                if (!resolved.empty() && IsSkipped(resolved, availStr)) isSkippedEntry = true;
            }
        } catch(...) {}
        if (isSkippedEntry && !showSkippedChecked) {
            // skip adding this row entirely
            continue;
        }
        SendMessageW(hList, LVM_SETITEMW, 0, (LPARAM)&lviSkip);
    }
    // After populating items, reapply header labels/formats now that results are present
    try {
        HWND hHeader = ListView_GetHeader(hList);
        if (hHeader) {
            HFONT hf = (HFONT)SendMessageW(hList, WM_GETFONT, 0, 0);
            if (hf) SendMessageW(hHeader, WM_SETFONT, (WPARAM)hf, TRUE);
            for (int ci = 0; ci < 4; ++ci) {
                HDITEMW hi{};
                hi.mask = HDI_FORMAT | HDI_TEXT;
                if (ci == 0) hi.fmt = HDF_LEFT;
                else if (ci == 1) hi.fmt = HDF_LEFT;
                else if (ci == 2) hi.fmt = HDF_RIGHT;
                else hi.fmt = HDF_CENTER;
                hi.pszText = (LPWSTR)g_colHeaders[ci].c_str();
                SendMessageW(hHeader, HDM_SETITEMW, (WPARAM)ci, (LPARAM)&hi);
            }
            InvalidateRect(hHeader, NULL, TRUE);
            UpdateWindow(hHeader);
            // Force apply header text/format and redraw as a stronger fallback
            ForceApplyHeaderTexts(hList);
            // Write a guaranteed header_create marker into workspace logs so it's easy to inspect
            try {
                wchar_t cwdBuf[MAX_PATH] = {0};
                if (GetCurrentDirectoryW((DWORD)std::size(cwdBuf), cwdBuf)) {
                    std::wstring cwd(cwdBuf);
                    std::wstring logsDir = cwd + L"\\logs";
                    CreateDirectoryW(logsDir.c_str(), NULL);
                    std::wstring outfn = logsDir + L"\\header_create.txt";
                    HANDLE hf = CreateFileW(outfn.c_str(), GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
                    if (hf != INVALID_HANDLE_VALUE) {
                        std::string s;
                        s += "PID=" + std::to_string(GetCurrentProcessId()) + "\n";
                        s += "TS=" + WideToUtf8(GetTimestampNow()) + "\n";
                        for (int ci = 0; ci < 4; ++ci) {
                            std::string txt = (ci < (int)g_colHeaders.size()) ? WideToUtf8(g_colHeaders[ci]) : std::string();
                            s += std::to_string(ci) + ": " + txt + " fmt=";
                            if (ci == 0) s += "HDF_LEFT";
                            else if (ci == 1) s += "HDF_LEFT";
                            else if (ci == 2) s += "HDF_RIGHT";
                            else s += "HDF_CENTER";
                            s += "\n";
                        }
                        DWORD written = 0;
                        WriteFile(hf, s.data(), (DWORD)s.size(), &written, NULL);
                        CloseHandle(hf);
                        // Do not write header_create file into workspace; record to app log instead
                        try { AppendLog(std::string("PopulateListView: header_create info written (not persisted to workspace)\n")); } catch(...) {}
                    }
                }
            } catch(...) {}
        }
        // ensure the column formats are correct
        for (int ci = 0; ci < 4; ++ci) {
            LVCOLUMNW setcol{};
            setcol.mask = LVCF_FMT | LVCF_TEXT;
            if (ci == 0) setcol.fmt = LVCFMT_LEFT;
            else if (ci == 1) setcol.fmt = LVCFMT_RIGHT;
            else if (ci == 2) setcol.fmt = LVCFMT_RIGHT;
            else setcol.fmt = LVCFMT_CENTER;
            setcol.pszText = (LPWSTR)g_colHeaders[ci].c_str();
            SendMessageW(hList, LVM_SETCOLUMNW, (WPARAM)ci, (LPARAM)&setcol);
        }
        // marker files to confirm populate path executed (write to cwd logs, exe-dir logs, and temp)
        try {
            // cwd-relative logs
            std::ofstream marker1("logs/header_after_populate.txt", std::ios::binary | std::ios::app);
            if (marker1) {
                marker1 << "PopulateListView header applied PID=" << GetCurrentProcessId() << "\n";
                for (size_t i = 0; i < g_colHeaders.size(); ++i) marker1 << i << ": " << WideToUtf8(g_colHeaders[i]) << "\n";
                marker1 << "----\n";
                marker1.close();
            }
        } catch(...) {}
        try {
            // exe-directory logs
            wchar_t modBuf[MAX_PATH] = {0};
            if (GetModuleFileNameW(NULL, modBuf, (DWORD)std::size(modBuf))) {
                std::wstring modPath(modBuf);
                size_t p = modPath.find_last_of(L"\\/");
                std::wstring exeDir = (p == std::wstring::npos) ? std::wstring(L".") : modPath.substr(0, p);
                std::wstring logsDir = exeDir + L"\\logs";
                CreateDirectoryW(logsDir.c_str(), NULL);
                std::wstring outfn = logsDir + L"\\header_after_populate.txt";
                std::ofstream marker2(WideToUtf8(outfn), std::ios::binary | std::ios::app);
                if (marker2) {
                    marker2 << "PopulateListView header applied PID=" << GetCurrentProcessId() << " EXE_DIR=" << WideToUtf8(exeDir) << "\n";
                    for (size_t i = 0; i < g_colHeaders.size(); ++i) marker2 << i << ": " << WideToUtf8(g_colHeaders[i]) << "\n";
                    marker2 << "----\n";
                    marker2.close();
                }
            }
        } catch(...) {}
        try {
            // temp folder
            wchar_t tmpPathBuf[MAX_PATH] = {0};
            if (GetTempPathW((DWORD)std::size(tmpPathBuf), tmpPathBuf)) {
                std::wstring tdir(tmpPathBuf);
                std::wstring outfn_tmp = tdir + L"wup_header_after_populate.txt";
                std::ofstream marker3(WideToUtf8(outfn_tmp), std::ios::binary | std::ios::app);
                if (marker3) {
                    marker3 << "PopulateListView header applied PID=" << GetCurrentProcessId() << " TMP=" << WideToUtf8(tdir) << "\n";
                    for (size_t i = 0; i < g_colHeaders.size(); ++i) marker3 << i << ": " << WideToUtf8(g_colHeaders[i]) << "\n";
                    marker3 << "----\n";
                    marker3.close();
                }
            }
        } catch(...) {}
    } catch(...) {}
}

static void AdjustListColumns(HWND hList) {
    RECT rc; GetClientRect(hList, &rc);
    int totalW = rc.right - rc.left;
    if (totalW <= 0) return;
    int wCur = (int)(totalW * 0.15);
    int wAvail = (int)(totalW * 0.15);
    int wSkip = (int)(totalW * 0.10);
    int wName = totalW - (wCur + wAvail + wSkip) - 4;
    ListView_SetColumnWidth(hList, 0, wName);
    ListView_SetColumnWidth(hList, 1, wCur);
    ListView_SetColumnWidth(hList, 2, wAvail);
    ListView_SetColumnWidth(hList, 3, wSkip);
    // Adjust font if needed (shrink if columns exceed width)
    // For simplicity, leave font as-is; could implement dynamic font sizing here.
}

// Show a localized skip confirmation using TaskDialogIndirect with custom button labels.
// ShowSkipConfirm moved to main.cpp to be linked into the build

// Helper used by custom draw / notifications: check if item index corresponds to NotApplicable id
static bool IsItemNotApplicable(int index) {
    if (index < 0 || index >= (int)g_packages.size()) return false;
    std::string id = g_packages[index].first;
    std::lock_guard<std::mutex> lk(g_packages_mutex);
    return g_not_applicable_ids.find(id) != g_not_applicable_ids.end();
}

// Parse the standard `winget upgrade` table which has columns: Name | Id | Version | Available
// Add entries where Available > Version.
static void ParseWingetUpgradeTableForUpdates(const std::string &text, std::set<std::pair<std::string,std::string>> &outSet) {
    std::istringstream iss(text);
    std::vector<std::string> lines;
    std::string line;
    while (std::getline(iss, line)) {
        while (!line.empty() && (line.back()=='\r' || line.back()=='\n')) line.pop_back();
        lines.push_back(line);
    }
    if (lines.empty()) return;

    int headerIdx = -1, sepIdx = -1;
    for (int i = 0; i < (int)lines.size(); ++i) {
        if (lines[i].find("----") != std::string::npos) { sepIdx = i; break; }
    }
    if (sepIdx <= 0) return;
    headerIdx = sepIdx - 1;
    std::string header = lines[headerIdx];

    auto trim = [](std::string s){ while(!s.empty() && isspace((unsigned char)s.front())) s.erase(s.begin()); while(!s.empty() && isspace((unsigned char)s.back())) s.pop_back(); return s; };
    std::vector<std::string> colNames = {"Name","Id","Version","Available"};
    std::vector<int> colStarts;
    for (auto &cn : colNames) {
        size_t p = header.find(cn);
        if (p != std::string::npos) colStarts.push_back((int)p);
    }
    if (colStarts.size() < 3) return;

    for (int i = sepIdx + 1; i < (int)lines.size(); ++i) {
        const std::string &ln = lines[i];
        if (trim(ln).empty()) continue;
        // stop on summary line
        if (ln.find("upgrades available") != std::string::npos) break;
        int ncols = (int)colStarts.size();
        auto substrSafe = [&](const std::string &s, int a, int b)->std::string{
            int len = (int)s.size();
            if (a >= len) return std::string();
            int end = std::min(len, b);
            return s.substr(a, end - a);
        };
        std::vector<std::string> fields(ncols);
        for (int c = 0; c < ncols; ++c) {
            int a = colStarts[c];
            int b = (c+1 < ncols) ? colStarts[c+1] : (int)ln.size();
            fields[c] = trim(substrSafe(ln, a, b));
        }
        std::string name = fields[0];
        std::string id = (ncols > 1) ? fields[1] : std::string();
        std::string installed = (ncols > 2) ? fields[2] : std::string();
        std::string available = (ncols > 3) ? fields[3] : std::string();
        if (id.empty()) continue;
        if (CompareVersions(installed, available) < 0) outSet.emplace(id, name.empty()?id:name);
    }
}

// Dump parsed packages and current ListView items to a temp file for debugging
static std::wstring DumpPackagesAndListViewToTemp(HWND hList) {
    wchar_t curDir[MAX_PATH];
    GetCurrentDirectoryW(MAX_PATH, curDir);
    unsigned long long uniq = GetTickCount64();
    wchar_t outfn[MAX_PATH];
    swprintf(outfn, _countof(outfn), L"%s\\wup_dump_%llu.txt", curDir, uniq);
    std::string nfn = WideToUtf8(outfn);
    std::ofstream ofs(nfn, std::ios::binary);
    if (!ofs) return std::wstring();
    ofs << "Parsed packages:\r\n";
    for (auto &p : g_packages) {
        ofs << p.first << "\t" << p.second << "\r\n";
    }
    ofs << "\r\nListView items:\r\n";
    int cnt = ListView_GetItemCount(hList);
    for (int i = 0; i < cnt; ++i) {
        wchar_t buf[1024] = {0};
        LVITEMW lvi{};
        lvi.iItem = i; lvi.iSubItem = 0; lvi.mask = LVIF_TEXT; lvi.pszText = buf; lvi.cchTextMax = _countof(buf);
        SendMessageW(hList, LVM_GETITEMW, 0, (LPARAM)&lvi);
        std::wstring wtext(buf);
        std::string stext = WideToUtf8(wtext);
        ofs << stext << "\r\n";
    }
    ofs.close();
    return std::wstring(outfn);
}

// Write arbitrary UTF-8 text to a temp file and return its path
static std::wstring WriteDebugTextToTemp(const std::string &txt) {
    wchar_t curDir[MAX_PATH];
    GetCurrentDirectoryW(MAX_PATH, curDir);
    unsigned long long uniq = GetTickCount64();
    wchar_t outfn[MAX_PATH];
    swprintf(outfn, _countof(outfn), L"%s\\wupdbg_%llu.txt", curDir, uniq);
    std::string nfn = WideToUtf8(outfn);
    std::ofstream ofs(nfn, std::ios::binary);
    if (!ofs) return std::wstring();
    ofs << txt;
    ofs.close();
    return std::wstring(outfn);
}

// Remove any stale temp files created by previous runs (wup_install_*.txt)
static void CleanupStaleInstallFiles() {
    try {
        wchar_t tmpPathBuf[MAX_PATH]; GetTempPathW(MAX_PATH, tmpPathBuf);
        std::wstring tmpPath(tmpPathBuf);
        namespace fs = std::filesystem;
        for (auto &e : fs::directory_iterator(tmpPath)) {
            try {
                if (!e.is_regular_file()) continue;
                std::wstring fn = e.path().filename().wstring();
                if (fn.rfind(L"wup_install_", 0) == 0) {
                    fs::remove(e.path());
                }
            } catch(...) { /* ignore per-file errors */ }
        }
    } catch(...) {}
}

static void CheckAllItems(HWND hList, bool check) {
    int count = ListView_GetItemCount(hList);
    for (int i = 0; i < count; ++i) {
        bool skip = false;
        if (i >= 0 && i < (int)g_packages.size()) {
            std::string id = g_packages[i].first;
            std::lock_guard<std::mutex> lk(g_packages_mutex);
            skip = (g_skipped_versions.find(id) != g_skipped_versions.end());
        }
        if (!skip) ListView_SetCheckState(hList, i, check);
    }
}

// Parse raw winget upgrade output, update startup/live version maps and write logfile.
static void CaptureStartupVersions(const std::string &rawOut,
                                   const std::vector<std::pair<std::string,std::string>> &results,
                                   const std::unordered_map<std::string,std::string> &avail,
                                   const std::unordered_map<std::string,std::string> &inst,
                                   bool forceOverwrite = false) {
    try {
        std::vector<std::tuple<std::string,std::string,std::string,std::string>> parsedRows;
        std::string localRaw = rawOut;
        // prefer existing raw file if present
        try {
            std::string fileTxt = ReadFileUtf8(std::wstring(L"logs\\wup_winget_raw.txt"));
            if (!fileTxt.empty()) localRaw = fileTxt;
        } catch(...) {}
        if (localRaw.empty()) {
            try {
                auto fresh = RunProcessCaptureExitCode(L"winget upgrade", 15000);
                if (!fresh.second.empty()) localRaw = fresh.second;
            } catch(...) {}
        }
        // Right-to-left token parsing (robust against variable name widths)
        if (!localRaw.empty()) {
            std::istringstream ois(localRaw);
            std::string line;
            std::vector<std::string> allLines;
            while (std::getline(ois, line)) allLines.push_back(line);
            size_t startIdx = (allLines.size() > 2) ? 2 : 0;
            for (size_t i = startIdx; i < allLines.size(); ++i) {
                std::string row = allLines[i];
                auto trimRow = [](std::string &s){ while(!s.empty() && (s.back()=='\r' || s.back()=='\n')) s.pop_back(); while(!s.empty() && isspace((unsigned char)s.front())) s.erase(s.begin()); while(!s.empty() && isspace((unsigned char)s.back())) s.pop_back(); };
                trimRow(row);
                if (row.empty()) continue;
                if (row.find("----") != std::string::npos) continue;
                if (row.find("upgrades available") != std::string::npos) break;
                std::istringstream ls(row);
                std::vector<std::string> toks;
                std::string tok;
                while (ls >> tok) toks.push_back(tok);
                if (toks.size() < 4) continue;
                std::string source = toks.back(); toks.pop_back();
                std::string available = toks.back(); toks.pop_back();
                std::string installed = toks.back(); toks.pop_back();
                std::string id = toks.back(); toks.pop_back();
                std::string name;
                for (size_t k = 0; k < toks.size(); ++k) { if (k) name += " "; name += toks[k]; }
                if (name.empty()) name = id;
                parsedRows.emplace_back(name, id, installed, available);
            }
        }

        // If parsed rows found, update startup maps and live caches
        if (!parsedRows.empty()) {
            try {
                std::lock_guard<std::mutex> lk(g_startup_versions_mutex);
                if (forceOverwrite || g_startup_avail_versions.empty() && g_startup_inst_versions.empty()) {
                    for (auto &t : parsedRows) {
                        const std::string &id = std::get<1>(t);
                        const std::string &installed = std::get<2>(t);
                        const std::string &available = std::get<3>(t);
                        g_startup_inst_versions[id] = installed;
                        g_startup_avail_versions[id] = available;
                    }
                }
            } catch(...) {}
            try {
                std::lock_guard<std::mutex> vlk(g_versions_mutex);
                for (auto &t : parsedRows) {
                    const std::string &id = std::get<1>(t);
                    const std::string &installed = std::get<2>(t);
                    const std::string &available = std::get<3>(t);
                    if (!installed.empty()) g_last_inst_versions[id] = installed;
                    if (!available.empty()) g_last_avail_versions[id] = available;
                }
            } catch(...) {}
        } else {
            // fallback: use avail/inst maps and discovered results
            try {
                std::lock_guard<std::mutex> lk(g_startup_versions_mutex);
                std::unordered_set<std::string> candidateIds;
                for (auto &p : results) candidateIds.insert(p.first);
                if (candidateIds.empty()) {
                    for (auto &a : avail) {
                        const std::string &id = a.first;
                        auto itInst = inst.find(id);
                        if (itInst == inst.end()) continue;
                        try {
                            if (CompareVersions(itInst->second, a.second) < 0) candidateIds.insert(id);
                        } catch(...) {
                            if (itInst->second != a.second) candidateIds.insert(id);
                        }
                    }
                }
                for (auto &id : candidateIds) {
                    auto ait = avail.find(id);
                    if (ait != avail.end()) g_startup_avail_versions[id] = ait->second;
                    auto iit = inst.find(id);
                    if (iit != inst.end()) g_startup_inst_versions[id] = iit->second;
                    // also update live caches
                    try {
                        std::lock_guard<std::mutex> vlk(g_versions_mutex);
                        if (iit != inst.end() && !iit->second.empty()) g_last_inst_versions[id] = iit->second;
                        if (ait != avail.end() && !ait->second.empty()) g_last_avail_versions[id] = ait->second;
                    } catch(...) {}
                }
            } catch(...) {}
        }

        // No logfile output requested: keep parsed startup data in memory only.
    } catch(...) {}
}

LRESULT CALLBACK WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
    static HWND hRadioShow, hRadioAll, hBtnRefresh, hList, hCheckAll, hBtnUpgrade;
    switch (uMsg) {
    case WM_CREATE: {
        INITCOMMONCONTROLSEX icce{ sizeof(icce), ICC_LISTVIEW_CLASSES };
        InitCommonControlsEx(&icce);

        // Title (H2-like centered)
        HDC hdcTitle = GetDC(hwnd);
        int lfTitleHeight = -MulDiv(14, GetDeviceCaps(hdcTitle, LOGPIXELSY), 72);
        ReleaseDC(hwnd, hdcTitle);
        g_hTitleFont = CreateFontW(lfTitleHeight, 0, 0, 0, FW_BOLD, FALSE, FALSE, FALSE,
            DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, NONANTIALIASED_QUALITY,
            DEFAULT_PITCH | FF_SWISS, L"Segoe UI");
        // Title moved right to make space for left-aligned language combo
        g_hTitle = CreateWindowExW(0, L"Static", L"WinUpdate", WS_CHILD | WS_VISIBLE | SS_CENTER, 80, 10, 530, 28, hwnd, NULL, NULL, NULL);
        if (g_hTitle && g_hTitleFont) SendMessageW(g_hTitle, WM_SETFONT, (WPARAM)g_hTitleFont, TRUE);

        // language selection combobox (top-left)
        HWND hComboLang = CreateWindowExW(0, WC_COMBOBOXW, NULL, WS_CHILD | WS_VISIBLE | CBS_DROPDOWNLIST | WS_TABSTOP, 10, 10, 150, 200, hwnd, (HMENU)IDC_COMBO_LANG, NULL, NULL);
        if (hComboLang) {
            SendMessageW(hComboLang, CB_ADDSTRING, 0, (LPARAM)L"English (en)");
            SendMessageW(hComboLang, CB_ADDSTRING, 0, (LPARAM)L"Norsk (no)");
            // select based on g_locale (prefix)
            int sel = 0;
            if (g_locale.rfind("no",0) == 0) sel = 1;
            SendMessageW(hComboLang, CB_SETCURSEL, sel, 0);
        }

        // Last-updated label (small bold ~9pt) placed under the title and centered
        HDC hdc = GetDC(hwnd);
        int lfHeight = -MulDiv(9, GetDeviceCaps(hdc, LOGPIXELSY), 72);
        ReleaseDC(hwnd, hdc);
        g_hLastUpdatedFont = CreateFontW(lfHeight, 0, 0, 0, FW_BOLD, FALSE, FALSE, FALSE,
            DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, NONANTIALIASED_QUALITY,
            DEFAULT_PITCH | FF_SWISS, L"Segoe UI");
        g_hLastUpdated = CreateWindowExW(0, L"Static", L"List last updated: N/A", WS_CHILD | WS_VISIBLE | SS_CENTER, 10, 40, 600, 16, hwnd, NULL, NULL, NULL);
        if (g_hLastUpdated && g_hLastUpdatedFont) SendMessageW(g_hLastUpdated, WM_SETFONT, (WPARAM)g_hLastUpdatedFont, TRUE);

        hList = CreateWindowExW(WS_EX_CLIENTEDGE, WC_LISTVIEWW, NULL, WS_CHILD | WS_VISIBLE | LVS_REPORT | LVS_SHOWSELALWAYS | LVS_SINGLESEL, 10, 60, 600, 284, hwnd, (HMENU)IDC_LISTVIEW, NULL, NULL);
        ListView_SetExtendedListViewStyle(hList, LVS_EX_CHECKBOXES | LVS_EX_FULLROWSELECT | LVS_EX_GRIDLINES | LVS_EX_DOUBLEBUFFER);
        // prepare persistent column header strings so pointers remain valid
        g_colHeaders.clear();
        g_colHeaders.push_back(t("package_col"));
        g_colHeaders.push_back(t("current_col"));
        g_colHeaders.push_back(t("available_col"));
        g_colHeaders.push_back(t("skip_col"));
        LVCOLUMNW col{};
        col.mask = LVCF_TEXT | LVCF_WIDTH | LVCF_FMT;
        col.cx = 420;
        col.fmt = LVCFMT_LEFT;
        col.pszText = (LPWSTR)g_colHeaders[0].c_str();
        ListView_InsertColumn(hList, 0, &col);
        LVCOLUMNW colCur{}; colCur.mask = LVCF_TEXT | LVCF_WIDTH | LVCF_FMT; colCur.cx = 100; colCur.fmt = LVCFMT_RIGHT; colCur.pszText = (LPWSTR)g_colHeaders[1].c_str(); ListView_InsertColumn(hList, 1, &colCur);
        LVCOLUMNW colAvail{}; colAvail.mask = LVCF_TEXT | LVCF_WIDTH | LVCF_FMT; colAvail.cx = 100; colAvail.fmt = LVCFMT_RIGHT; colAvail.pszText = (LPWSTR)g_colHeaders[2].c_str(); ListView_InsertColumn(hList, 2, &colAvail);
        LVCOLUMNW colSkip{}; colSkip.mask = LVCF_TEXT | LVCF_WIDTH | LVCF_FMT; colSkip.cx = 80; colSkip.fmt = LVCFMT_CENTER; colSkip.pszText = (LPWSTR)g_colHeaders[3].c_str(); ListView_InsertColumn(hList, 3, &colSkip);
        // Ensure header labels are set from persistent buffers and formats applied.
        HWND hHeader = ListView_GetHeader(hList);
        if (hHeader) {
            for (int ci = 0; ci < 4; ++ci) {
                HDITEMW hi{};
                hi.mask = HDI_FORMAT | HDI_TEXT;
                if (ci == 0) hi.fmt = HDF_LEFT;
                else if (ci == 1) hi.fmt = HDF_LEFT; // Installed header left-aligned
                else if (ci == 2) hi.fmt = HDF_RIGHT; // Available header right-aligned
                else hi.fmt = HDF_CENTER;
                hi.pszText = (LPWSTR)g_colHeaders[ci].c_str();
                SendMessageW(hHeader, HDM_SETITEMW, ci, (LPARAM)&hi);
            }
            // Subclass header to force paint of our text if not already done
            if (!g_header_subclassed) {
                SetWindowSubclass(hHeader, HeaderSubclassProc, 1, 0);
                g_header_subclassed = true;
            }
        }
        // Force header redraw and also write a debug file into the workspace logs folder
        if (hHeader) {
            InvalidateRect(hHeader, NULL, TRUE);
            UpdateWindow(hHeader);
        }
        // ensure header subclassing in case header created earlier paths didn't attach
        if (hHeader && !g_header_subclassed) {
            SetWindowSubclass(hHeader, HeaderSubclassProc, 1, 0);
            g_header_subclassed = true;
        }
        // Spawn probe messagebox now (main window WM_CREATE)
        try { SpawnProbeMessageBoxAt(200,200, L"Probe: WM_CREATE", L"Probe launched from main WM_CREATE"); } catch(...) {}
        // Ensure ListView redraw as well
        if (hList) {
            RedrawWindow(hList, NULL, NULL, RDW_INVALIDATE | RDW_ERASE | RDW_FRAME | RDW_UPDATENOW);
        }
        try {
            // Primary: write to workspace-relative logs\header_debug.txt (most runs use project cwd)
            std::wstring outfn_rel = L"logs\\header_debug.txt";
            {
                std::ofstream hdbg_rel(WideToUtf8(outfn_rel), std::ios::binary | std::ios::trunc);
                if (hdbg_rel) {
                    hdbg_rel << "PID=" << GetCurrentProcessId() << "\n";
                    wchar_t cwdBuf[MAX_PATH] = {0};
                    if (GetCurrentDirectoryW((DWORD)std::size(cwdBuf), cwdBuf)) {
                        hdbg_rel << "CWD=" << WideToUtf8(cwdBuf) << "\n";
                    }
                    for (size_t i = 0; i < g_colHeaders.size(); ++i) {
                        hdbg_rel << i << ": " << WideToUtf8(g_colHeaders[i]) << "\n";
                    }
                    hdbg_rel.close();
                }
            }
            // Also write to exe-directory logs to catch cases where cwd differs
            wchar_t modBuf2[MAX_PATH] = {0};
            if (GetModuleFileNameW(NULL, modBuf2, (DWORD)std::size(modBuf2))) {
                std::wstring modPath(modBuf2);
                size_t p2 = modPath.find_last_of(L"\\/");
                std::wstring exeDir = (p2 == std::wstring::npos) ? std::wstring(L".") : modPath.substr(0, p2);
                std::wstring logsDir = exeDir + L"\\logs";
                CreateDirectoryW(logsDir.c_str(), NULL);
                std::wstring outfn_exe = logsDir + L"\\header_debug.txt";
                std::ofstream hdbg_exe(WideToUtf8(outfn_exe), std::ios::binary | std::ios::trunc);
                if (hdbg_exe) {
                    hdbg_exe << "PID=" << GetCurrentProcessId() << "\n";
                    hdbg_exe << "EXE_DIR=" << WideToUtf8(exeDir) << "\n";
                    for (size_t i = 0; i < g_colHeaders.size(); ++i) {
                        hdbg_exe << i << ": " << WideToUtf8(g_colHeaders[i]) << "\n";
                    }
                    hdbg_exe.close();
                }
            }
            // Also write to temp folder so user can easily find it: GetTempPath
            wchar_t tmpPathBuf[MAX_PATH] = {0};
            if (GetTempPathW((DWORD)std::size(tmpPathBuf), tmpPathBuf)) {
                std::wstring tdir(tmpPathBuf);
                std::wstring outfn_tmp = tdir + L"wup_header_debug.txt";
                std::ofstream hdbg_tmp(WideToUtf8(outfn_tmp), std::ios::binary | std::ios::trunc);
                if (hdbg_tmp) {
                    hdbg_tmp << "PID=" << GetCurrentProcessId() << "\n";
                    hdbg_tmp << "TMP=" << WideToUtf8(tdir) << "\n";
                    for (size_t i = 0; i < g_colHeaders.size(); ++i) {
                        hdbg_tmp << i << ": " << WideToUtf8(g_colHeaders[i]) << "\n";
                    }
                    hdbg_tmp.close();
                }
            }
        } catch(...) {}
        // DEBUG: show header contents on startup so we can confirm runtime values
        try {
            std::wstring dbg = g_colHeaders[0] + L"\n" + g_colHeaders[1] + L"\n" + g_colHeaders[2] + L"\n" + g_colHeaders[3];
            MessageBoxW(hwnd, dbg.c_str(), L"Header debug", MB_OK | MB_ICONINFORMATION);
        } catch(...) {}
        // Debug: write header strings to logs next to the executable to avoid current_path mismatches
        try {
            wchar_t modBuf[MAX_PATH] = {0};
            if (GetModuleFileNameW(NULL, modBuf, (DWORD)std::size(modBuf))) {
                std::wstring modPath(modBuf);
                size_t p = modPath.find_last_of(L"\\/");
                std::wstring exeDir = (p == std::wstring::npos) ? std::wstring(L".") : modPath.substr(0, p);
                std::wstring logsDir = exeDir + L"\\logs";
                CreateDirectoryW(logsDir.c_str(), NULL);
                std::wstring outfn = logsDir + L"\\header_debug.txt";
                std::ofstream hdbg(WideToUtf8(outfn), std::ios::binary | std::ios::trunc);
                if (hdbg) {
                    for (size_t i = 0; i < g_colHeaders.size(); ++i) {
                        hdbg << i << ": " << WideToUtf8(g_colHeaders[i]) << "\n";
                    }
                    hdbg.close();
                }
            }
        } catch(...) {}

        hCheckAll = CreateWindowExW(0, L"Button", t("select_all").c_str(), WS_CHILD | WS_VISIBLE | BS_AUTOCHECKBOX, 10, 350, 120, 24, hwnd, (HMENU)IDC_CHECK_SELECTALL, NULL, NULL);
        HWND hCheckSkip = CreateWindowExW(0, L"Button", t("skip_col").c_str(), WS_CHILD | WS_VISIBLE | BS_AUTOCHECKBOX, 140, 350, 140, 24, hwnd, (HMENU)IDC_CHECK_SKIPSELECTED, NULL, NULL);
        // Temporarily disable the Skip control until feature is stable
        if (hCheckSkip) EnableWindow(hCheckSkip, FALSE);
        // place Upgrade button 5px to the right of Select all
        hBtnUpgrade = CreateWindowExW(0, L"Button", t("upgrade_now").c_str(), WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON, 135, 350, 220, 28, hwnd, (HMENU)IDC_BTN_UPGRADE, NULL, NULL);
        // Show skipped checkbox between Upgrade and Refresh
        HWND hCheckShowSkipped = CreateWindowExW(0, L"Button", t("show_skipped").c_str(), WS_CHILD | WS_VISIBLE | BS_AUTOCHECKBOX, 365, 350, 120, 24, hwnd, (HMENU)IDC_CHECK_SHOW_SKIPPED, NULL, NULL);
        // Unskip selected (hidden by default). Place between Upgrade and Refresh.
        HWND hBtnUnskip = CreateWindowExW(0, L"Button", t("unskip_selected").c_str(), WS_CHILD | BS_PUSHBUTTON, 365, 350, 100, 28, hwnd, (HMENU)IDC_BTN_UNSKIP, NULL, NULL);
        if (hBtnUnskip) ShowWindow(hBtnUnskip, SW_HIDE);
        // position Refresh where the Upgrade button used to be (bottom-right)
        hBtnRefresh = CreateWindowExW(0, L"Button", t("refresh").c_str(), WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON, 470, 350, 140, 28, hwnd, (HMENU)IDC_BTN_REFRESH, NULL, NULL);

        // About button at top-right (owner-draw so we can color on hover/press)
        HWND hBtnAbout = CreateWindowExW(0, L"Button", L"About", WS_CHILD | WS_VISIBLE | BS_OWNERDRAW | WS_TABSTOP, 470, 10, 120, 28, hwnd, (HMENU)IDC_BTN_ABOUT, NULL, NULL);
        if (hBtnAbout) {
            // subclass to track mouse hover/leave and store state in GWLP_USERDATA
            SetWindowSubclass(hBtnAbout, [](HWND h, UINT msg, WPARAM wp, LPARAM lp, UINT_PTR, DWORD_PTR)->LRESULT {
                switch (msg) {
                case WM_MOUSEMOVE: {
                    // set hover flag
                    SetWindowLongPtrW(h, GWLP_USERDATA, 1);
                    // request redraw of parent so WM_DRAWITEM runs
                    InvalidateRect(h, NULL, TRUE);
                    TRACKMOUSEEVENT tme{}; tme.cbSize = sizeof(tme); tme.dwFlags = TME_LEAVE; tme.hwndTrack = h; TrackMouseEvent(&tme);
                    break;
                }
                case WM_MOUSELEAVE: {
                    SetWindowLongPtrW(h, GWLP_USERDATA, 0);
                    InvalidateRect(h, NULL, TRUE);
                    break;
                }
                }
                return DefSubclassProc(h, msg, wp, lp);
            }, 0, 0);
        }
        // record main window handle, initial timestamp and auto-refresh once UI is created (start async refresh)
        g_hMainWindow = hwnd;
        // clean up any stale install temp files from previous runs
        CleanupStaleInstallFiles();
        UpdateLastUpdatedLabel(hwnd);
        ShowLoading(hwnd);
        if (!g_refresh_in_progress.load()) PostMessageW(hwnd, WM_REFRESH_ASYNC, 0, 0);
        // Post a follow-up message to reapply header text/format after the window has been created
        // Use a short timer to defer so header creation/layout completes first
        SetTimer(hwnd, REAPPLY_HEADERS_TIMER_ID, 120, NULL);
        break;
    }
    case WM_REFRESH_ASYNC: {
        // wParam: non-zero = manual refresh (user requested). Use this to suppress automatic popups on startup.
        bool manual = (wParam != 0);
        // start background thread to perform winget query + parsing
        // disable Refresh button while running
        g_refresh_in_progress.store(true);
        if (hBtnRefresh) EnableWindow(hBtnRefresh, FALSE);
        if (hBtnUpgrade) EnableWindow(hBtnUpgrade, FALSE);
        ShowLoading(hwnd);
        std::thread([hwnd, manual]() {
            std::vector<std::pair<std::string,std::string>> results;

            // Fast-path: prefer a cached `winget list` and run `winget upgrade` with a short timeout.
            std::string listOut;
            try {
                namespace fs = std::filesystem;
                fs::path listPath = fs::current_path() / "wup_winget_list_fallback.txt";
                if (fs::exists(listPath)) {
                    try {
                        auto ftime = fs::last_write_time(listPath);
                        using file_clock = decltype(ftime)::clock;
                        auto file_now = file_clock::now();
                        auto sys_now = std::chrono::system_clock::now();
                        auto sctp = sys_now + (ftime - file_now);
                        auto age = std::chrono::system_clock::now() - sctp;
                        if (age < std::chrono::seconds(60)) {
                            listOut = ReadFileUtf8(listPath.wstring());
                        }
                    } catch(...) {}
                }
            } catch(...) {}

            if (listOut.empty()) {
                auto rlist = RunProcessCaptureExitCode(L"winget list", 1000);
                listOut = rlist.second;
                if (!listOut.empty()) {
                    try { std::ofstream ofs("wup_winget_list_fallback.txt", std::ios::binary); if (ofs) ofs << listOut; } catch(...) {}
                }
            }

            // Run winget upgrade with a 2s timeout (fast). If it returns quickly, parse it; if it times out/empty, treat list candidates as NotApplicable.
            auto rup = RunProcessCaptureExitCode(L"winget upgrade", 5000);
            std::string out = rup.second;
            bool timedOut = (rup.first == -2);
            // If initial fast attempt timed out or returned empty, try a longer attempt once
            if (timedOut || out.empty()) {
                auto rup2 = RunProcessCaptureExitCode(L"winget upgrade", 15000);
                if (!rup2.second.empty()) {
                    out = rup2.second;
                    timedOut = false;
                }
            }
            if (!out.empty()) {
                // Prefer the in-memory parser chain to extract Id/Name pairs
                auto vec = ParseRawWingetTextInMemory(out);
                std::set<std::pair<std::string,std::string>> found;
                for (auto &p : vec) found.emplace(p.first, p.second);
                // fallback: if we still have nothing and have a cached list, try the list-based mapping
                if (found.empty() && !listOut.empty()) {
                    FindUpdatesUsingKnownList(listOut, out, found);
                }
                for (auto &p : found) results.emplace_back(p.first, p.second);
            }

            // Probe available/installed versions in background and cache them
            try {
                auto avail = MapAvailableVersions();
                auto inst = MapInstalledVersions();
                {
                    std::lock_guard<std::mutex> lk(g_versions_mutex);
                    g_last_avail_versions = avail;
                    g_last_inst_versions = inst;
                }
                // Also capture a startup snapshot (write to logs for verification)
                try {
                    CaptureStartupVersions(out, results, avail, inst, false);
                } catch(...) {}
            } catch(...) {}

            if (out.empty() || timedOut) {
                // As a fast fallback: use the cached list to identify candidates and mark them NotApplicable (do not perform slow probes).
                if (!listOut.empty()) {
                    std::istringstream lss(listOut);
                    std::string ln;
                    std::regex anyRe("([\\S ]+?)\\s+([^\\s]+)\\s+(\\S+)\\s+(\\S+)");
                    std::smatch m;
                    std::set<std::string> localNA;
                    while (std::getline(lss, ln)) {
                        if (std::regex_search(ln, m, anyRe)) {
                            std::string id = m[2].str();
                            std::string installed = m[3].str();
                            std::string available = m[4].str();
                            try { if (CompareVersions(installed, available) < 0) localNA.insert(id); } catch(...) {}
                        }
                    }
                    if (!localNA.empty()) {
                        std::lock_guard<std::mutex> lk(g_packages_mutex);
                        g_not_applicable_ids = localNA;
                    }
                }
                // If winget upgrade returned empty and did NOT simply time out, remove stale fallback list
                // If it timed out, keep the fallback list so the UI can present candidates instead of claiming up-to-date.
                if (!timedOut) {
                    try {
                        namespace fs = std::filesystem;
                        fs::path listPath = fs::current_path() / "wup_winget_list_fallback.txt";
                        if (fs::exists(listPath)) fs::remove(listPath);
                    } catch(...) {}
                }
            }
            auto *pv = new std::vector<std::pair<std::string,std::string>>(std::move(results));
            // propagate manual flag to the WM_REFRESH_DONE handler via wParam so UI can decide whether to show popups
            PostMessageA(hwnd, WM_REFRESH_DONE, manual ? 1 : 0, (LPARAM)pv);
        }).detach();
        break;
    }
    case WM_REFRESH_DONE: {
        std::vector<std::pair<std::string,std::string>> *pv = (std::vector<std::pair<std::string,std::string>>*)lParam;
        if (pv) {
            // update global packages and UI
            {
                std::lock_guard<std::mutex> lk(g_packages_mutex);
                g_packages = *pv;
            }
            delete pv;
            // After updating g_packages, attempt to migrate any skipped entries that used display names
            try {
                bool migrated = MigrateSkippedEntries();
                if (migrated) {
                    // reload in-memory skipped map and refresh UI so migrated id-entries take effect immediately
                    try { LoadSkipConfig(g_locale); } catch(...) {}
                    if (hList) { PopulateListView(hList); AdjustListColumns(hList); }
                }
            } catch(...) {}
            if (hList) PopulateListView(hList);
            if (hList) AdjustListColumns(hList);
                // Ensure header texts and formats are reapplied after list population/resizing
                HWND hHeaderAfter = ListView_GetHeader(hList);
                if (hHeaderAfter) {
                    for (int ci = 0; ci < 4; ++ci) {
                        HDITEMW hi{};
                        hi.mask = HDI_FORMAT | HDI_TEXT;
                        if (ci == 0) hi.fmt = HDF_LEFT;
                        else if (ci == 1) hi.fmt = HDF_LEFT;
                        else if (ci == 2) hi.fmt = HDF_RIGHT;
                        else hi.fmt = HDF_CENTER;
                        hi.pszText = (LPWSTR)g_colHeaders[ci].c_str();
                        SendMessageW(hHeaderAfter, HDM_SETITEMW, ci, (LPARAM)&hi);
                    }
                    InvalidateRect(hHeaderAfter, NULL, TRUE);
                    UpdateWindow(hHeaderAfter);
                }
                // Explicitly restore column formats (important if columns were reset elsewhere)
                for (int ci = 0; ci < 4; ++ci) {
                    LVCOLUMNW setcol{};
                    setcol.mask = LVCF_FMT | LVCF_TEXT;
                    if (ci == 0) setcol.fmt = LVCFMT_LEFT;
                    else if (ci == 1) setcol.fmt = LVCFMT_RIGHT; // Installed: right-justify values
                    else if (ci == 2) setcol.fmt = LVCFMT_RIGHT;
                    else setcol.fmt = LVCFMT_CENTER;
                    setcol.pszText = (LPWSTR)g_colHeaders[ci].c_str();
                    SendMessageW(hList, LVM_SETCOLUMNW, ci, (LPARAM)&setcol);
                }
                // Redraw list to ensure alignment
                RedrawWindow(hList, NULL, NULL, RDW_INVALIDATE | RDW_ERASE | RDW_FRAME | RDW_UPDATENOW);
                // Append header debug to existing verbose logfile so we can inspect runtime values
                try {
                    std::ofstream vdbg("logs/wup_ui_setitems_verbose.txt", std::ios::binary | std::ios::app);
                    if (vdbg) {
                        vdbg << "--- header_dump PID=" << GetCurrentProcessId() << " ---\n";
                        for (size_t i = 0; i < g_colHeaders.size(); ++i) {
                            vdbg << i << ": " << WideToUtf8(g_colHeaders[i]) << "\n";
                        }
                        vdbg << "-------------------------------\n";
                        vdbg.close();
                    }
                } catch(...) {}
                // Also write a distinct marker file so it's easy to detect this exact code-path executed
                try {
                    std::ofstream marker("logs/header_after_scan.txt", std::ios::binary | std::ios::app);
                    if (marker) {
                        marker << "WM_REFRESH_DONE executed PID=" << GetCurrentProcessId() << " TS=" << WideToUtf8(GetTimestampNow()) << "\n";
                        for (size_t i = 0; i < g_colHeaders.size(); ++i) marker << i << ": " << WideToUtf8(g_colHeaders[i]) << "\n";
                        marker << "----\n";
                        marker.close();
                    }
                } catch(...) {}
                // Re-apply header text/format and force redraw to ensure visibility
                ForceApplyHeaderTexts(hList);
            // re-enable buttons
            if (hBtnRefresh) EnableWindow(hBtnRefresh, TRUE);
            if (hBtnUpgrade) EnableWindow(hBtnUpgrade, TRUE);
        }
        HideLoading();
        g_refresh_in_progress.store(false);
        // Ensure main UI controls are enabled after any refresh
        if (hList) EnableWindow(hList, TRUE);
        if (hBtnRefresh) EnableWindow(hBtnRefresh, TRUE);
        if (hBtnUpgrade) EnableWindow(hBtnUpgrade, TRUE);
        EnableWindow(GetDlgItem(hwnd, IDC_CHECK_SELECTALL), TRUE);
        EnableWindow(GetDlgItem(hwnd, IDC_COMBO_LANG), TRUE);
        // If the refresh produced no parsed packages, show an 'up-to-date' dialog
        {
            std::lock_guard<std::mutex> lk(g_packages_mutex);
            if (g_packages.empty()) {
                // Only show the 'up-to-date' popup if this was a manual refresh (user requested).
                if (wParam) {
                    std::wstring msg = t("your_system_updated");
                    MessageBoxW(hwnd, msg.c_str(), L"WinUpdate", MB_OK | MB_ICONINFORMATION);
                }
            }
        }
        // After refresh, prune skip config entries if versions advanced (use cached probe)
        try {
            auto avail = GetAvailableVersionsCached();
            bool changed = false;
            for (auto it = g_skipped_versions.begin(); it != g_skipped_versions.end();) {
                const std::string id = it->first;
                const std::string ver = it->second;
                auto f = avail.find(id);
                if (f == avail.end()) {
                    it = g_skipped_versions.erase(it);
                    changed = true;
                } else {
                    if (f->second != ver) {
                        it = g_skipped_versions.erase(it);
                        changed = true;
                    } else ++it;
                }
            }
            if (changed) SaveSkipConfig(g_locale);
            if (hList) PopulateListView(hList);
        } catch(...) {}
        break;
    }
    case WM_CTLCOLORSTATIC: {
        HDC hdcStatic = (HDC)wParam;
        HWND hwndCtl = (HWND)lParam;
        // make static controls blend with window background (transparent) and
        // set last-updated text to dark green
        if (hwndCtl == g_hLastUpdated) {
            SetTextColor(hdcStatic, RGB(0,100,0));
            SetBkMode(hdcStatic, TRANSPARENT);
            return (LRESULT)GetSysColorBrush(COLOR_WINDOW);
        }
        if (hwndCtl == g_hTitle) {
            SetBkMode(hdcStatic, TRANSPARENT);
            return (LRESULT)GetSysColorBrush(COLOR_WINDOW);
        }
        break;
    }
    case WM_SIZE: {
        if (hList) AdjustListColumns(hList);
        break;
    }
    case WM_APP+4: {
        // Reserved message: do not auto-destroy the install panel here to keep install output visible
        // This handler will only restore main controls if needed, but will not close panels.
        // wParam may contain a panel handle but we intentionally ignore it to avoid auto-closing.
        if (hList) EnableWindow(hList, TRUE);
        if (hBtnRefresh) EnableWindow(hBtnRefresh, TRUE);
        if (hBtnUpgrade) EnableWindow(hBtnUpgrade, TRUE);
        EnableWindow(GetDlgItem(hwnd, IDC_CHECK_SELECTALL), TRUE);
        EnableWindow(GetDlgItem(hwnd, IDC_COMBO_LANG), TRUE);
        break;
    }
    case WM_APP+6: {
        // wParam: 1 = show anim, 0 = hide anim
        HWND anim = g_hInstallAnim;
        if (anim && IsWindow(anim)) {
            if (wParam) ShowWindow(anim, SW_SHOW);
            else ShowWindow(anim, SW_HIDE);
        }
        break;
    }
    case WM_APP+7: {
        // Bring main window forward (sent from background thread after installs finish)
        TryForceForegroundWindow(hwnd);
        break;
    }
    case WM_APP+200: {
        // Hyperlink skip request: wParam = list index
        int idx = (int)wParam;
        AppendLog("[main] WM_APP+200 skip request idx=" + std::to_string(idx) + "\n");
        if (idx >= 0 && idx < (int)g_packages.size()) {
            std::string id = g_packages[idx].first;
            // Prefer to use the Available string as shown in the ListView so the exact
            // version the user sees is what's written to the per-user INI. If we cannot
            // retrieve it from the list control, fall back to cached probes.
            std::string ver = "";
            try {
                HWND hList = GetDlgItem(hwnd, IDC_LISTVIEW);
                if (hList && IsWindow(hList)) {
                    wchar_t buf[128] = {0};
                    LVITEMW lvi{}; lvi.iItem = idx; lvi.iSubItem = 2; lvi.cchTextMax = _countof(buf); lvi.pszText = buf; lvi.mask = LVIF_TEXT;
                    SendMessageW(hList, LVM_GETITEMW, 0, (LPARAM)&lvi);
                    if (buf[0] != 0) ver = WideToUtf8(std::wstring(buf));
                }
            } catch(...) {}
            if (ver.empty()) {
                try {
                    auto avail = GetAvailableVersionsCached();
                    auto it = avail.find(id);
                    if (it != avail.end()) ver = it->second;
                } catch(...) {}
            }
            if (ver.empty()) {
                // fallback: try direct map
                try { auto avail2 = MapAvailableVersions(); auto it2 = avail2.find(id); if (it2!=avail2.end()) ver = it2->second; } catch(...) {}
            }
            // Write quick workspace-level debug log so we can see handler execution
            try {
                std::string dbg = std::string("WM_APP+200 handler idx=") + std::to_string(idx) + " id=" + id + " ver=" + ver + "\n";
                WriteWorkspaceLogW(L"skip_handler.txt", dbg);
            } catch(...) {}

            bool added = AddSkippedEntry(id, ver);
            // (no interactive diagnostic) update in-memory map and persist
            if (added) {
                // update in-memory map and per-locale config so UI shows skipped state
                try { g_skipped_versions[id] = ver; SaveSkipConfig(g_locale); } catch(...) {}
                // ensure Show skipped control becomes visible
                HWND hUn = GetDlgItem(hwnd, IDC_BTN_UNSKIP); if (hUn) { ShowWindow(hUn, SW_SHOW); EnableWindow(hUn, TRUE); }
                // trigger immediate async refresh (user requested scan after skip)
                if (!g_refresh_in_progress.load()) PostMessageW(hwnd, WM_REFRESH_ASYNC, 1, 0);
            }
        }
        break;
    }
    case WM_COPYDATA: {
        PCOPYDATASTRUCT pcds = (PCOPYDATASTRUCT)lParam;
        if (!pcds || !pcds->lpData) break;
        try {
            std::string payload((char*)pcds->lpData, pcds->cbData ? pcds->cbData - 1 : 0);
            AppendLog(std::string("WM_COPYDATA: payload='") + payload + "'\n");
            // Expect payload starting with "WUP_SKIP\n<appname>\n<available>\n"
            if (payload.rfind("WUP_SKIP\n", 0) == 0) {
                size_t pos = 8; // after prefix
                size_t e1 = payload.find('\n', pos);
                if (e1 == std::string::npos) e1 = payload.size();
                std::string appn = payload.substr(pos, e1 - pos);
                size_t pos2 = (e1 == payload.size()) ? e1 : e1 + 1;
                size_t e2 = payload.find('\n', pos2);
                if (e2 == std::string::npos) e2 = payload.size();
                std::string avail = (pos2 <= e2) ? payload.substr(pos2, e2 - pos2) : std::string();
                // find matching package by displayed name (g_packages[][1] == name)
                int foundIdx = -1;
                // If g_packages is empty (UI may not have populated it yet), try
                // to repopulate from the most recent raw winget capture so we
                // can still resolve names->ids for WM_COPYDATA messages.
                try {
                    std::lock_guard<std::mutex> lkchk(g_packages_mutex);
                    if (g_packages.empty()) {
                        AppendLog(std::string("WM_COPYDATA: g_packages empty, attempting to repopulate from recent raw winget\n"));
                        try {
                            std::string raw = ReadMostRecentRawWinget();
                            if (!raw.empty()) {
                                ParseWingetTextForPackages(raw);
                                AppendLog(std::string("WM_COPYDATA: ParseWingetTextForPackages populated g_packages size=") + std::to_string((int)g_packages.size()) + "\n");
                            } else {
                                AppendLog("WM_COPYDATA: ReadMostRecentRawWinget returned empty\n");
                            }
                        } catch(...) { AppendLog("WM_COPYDATA: repopulate attempt threw\n"); }
                    }
                } catch(...) {}
                {
                    std::lock_guard<std::mutex> lk(g_packages_mutex);
                    for (int i = 0; i < (int)g_packages.size(); ++i) {
                        if (g_packages[i].second == appn) { foundIdx = i; break; }
                    }
                }
                AppendLog(std::string("WM_COPYDATA: foundIdx=") + std::to_string(foundIdx) + "\n");
                if (foundIdx < 0) {
                    // Try a more tolerant match: case-insensitive and substring matching
                    std::string appn_lower = appn; for (auto &c : appn_lower) c = (char)tolower((unsigned char)c);
                    std::lock_guard<std::mutex> lk2(g_packages_mutex);
                    for (int i = 0; i < (int)g_packages.size(); ++i) {
                        std::string nm = g_packages[i].second;
                        std::string nm_lower = nm; for (auto &c : nm_lower) c = (char)tolower((unsigned char)c);
                        if (nm_lower == appn_lower || nm_lower.find(appn_lower) != std::string::npos || appn_lower.find(nm_lower) != std::string::npos) { foundIdx = i; break; }
                    }
                    AppendLog(std::string("WM_COPYDATA: tolerant match foundIdx=") + std::to_string(foundIdx) + "\n");
                }
                if (foundIdx >= 0 && foundIdx < (int)g_packages.size()) {
                    std::string id = g_packages[foundIdx].first;
                    AppendLog(std::string("WM_COPYDATA: mapping appname->id='") + id + "' avail='" + avail + "'\n");
                    bool added = AddSkippedEntry(id, avail);
                    AppendLog(std::string("WM_COPYDATA: AddSkippedEntry returned ") + (added?"true":"false") + "\n");
                    // No interactive diagnostic here; update in-memory map and persist
                    if (added) {
                        try { g_skipped_versions[id] = avail; SaveSkipConfig(g_locale); } catch(...) {}
                        HWND hUn = GetDlgItem(hwnd, IDC_BTN_UNSKIP); if (hUn) { ShowWindow(hUn, SW_SHOW); EnableWindow(hUn, TRUE); }
                        if (!g_refresh_in_progress.load()) PostMessageW(hwnd, WM_REFRESH_ASYNC, 1, 0);
                    }
                }
            }
        } catch(...) {}
        break;
    }
    case WM_DRAWITEM: {
        LPDRAWITEMSTRUCT dis = (LPDRAWITEMSTRUCT)lParam;
        if (!dis) break;
        if (dis->CtlID == IDC_BTN_ABOUT) {
            HWND hBtn = dis->hwndItem;
            BOOL hover = (BOOL)GetWindowLongPtrW(hBtn, GWLP_USERDATA);
            bool pressed = (dis->itemState & ODS_SELECTED) != 0;
            HDC hdc = dis->hDC;
            RECT rc = dis->rcItem;
            // base dark-blue color and variations
            COLORREF base = RGB(10,57,129);
            COLORREF hoverCol = RGB(25,95,210);
            COLORREF pressCol = RGB(6,34,80);
            HBRUSH hBrush = CreateSolidBrush(pressed ? pressCol : (hover ? hoverCol : base));
            FillRect(hdc, &rc, hBrush);
            DeleteObject(hBrush);
            // draw text
            SetTextColor(hdc, RGB(255,255,255));
            SetBkMode(hdc, TRANSPARENT);
            HFONT hf = g_hLastUpdatedFont ? g_hLastUpdatedFont : (HFONT)GetStockObject(DEFAULT_GUI_FONT);
            HGDIOBJ oldf = SelectObject(hdc, hf);
            DrawTextW(hdc, L"About", -1, &rc, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
            SelectObject(hdc, oldf);
            if (dis->itemState & ODS_FOCUS) DrawFocusRect(hdc, &rc);
            return 0;
        }
        break;
    }
    case WM_INSTALL_DONE: {
        HWND panel = (HWND)wParam;
        if (panel && IsWindow(panel)) {
            // Only enable Done if this matches the current tracked install panel
            if (g_hInstallPanel == panel) {
                HWND hDoneBtn = GetDlgItem(hwnd, IDC_BTN_DONE);
                if (hDoneBtn) EnableWindow(hDoneBtn, TRUE);
            }
            // update the panel static status label if possible
            HWND hLabel = FindWindowExW(panel, NULL, L"Static", NULL);
            if (hLabel) SetWindowTextW(hLabel, t("your_system_updated").c_str());
            // hide animation when finished
            if (g_hInstallAnim) PostMessageW(hwnd, WM_APP+6, 0, 0);
            // NOTE: Do NOT re-enable or destroy main UI/panel here. Keep the install panel visible
            // until the user clicks Done so they can review all install output. Done handler will
            // re-enable controls and perform the refresh when the user is satisfied.
        }
        break;
    }
    case WM_TIMER: {
        if (wParam == REAPPLY_HEADERS_TIMER_ID) {
            KillTimer(hwnd, REAPPLY_HEADERS_TIMER_ID);
            PostMessageW(hwnd, WM_REAPPLY_HEADERS, 0, 0);
            return 0;
        }
        if (wParam == LOADING_TIMER_ID) {
            // loading timer is handled by the popup window; ignore here
            return 0;
        }
        break;
    }
    case WM_NOTIFY: {
        LPNMHDR pnm = (LPNMHDR)lParam;
        if (!pnm) break;
        if (pnm->idFrom == IDC_LISTVIEW) {
            if (pnm->code == LVN_ITEMCHANGING) {
                LPNMLISTVIEW p = (LPNMLISTVIEW)lParam;
                if (p && (p->uChanged & LVIF_STATE)) {
                    // detect checkbox state change via state image mask
                    if (((p->uNewState ^ p->uOldState) & LVIS_STATEIMAGEMASK) != 0) {
                        int idx = p->iItem;
                        if (IsItemNotApplicable(idx)) {
                            // cancel the change to prevent checking NotApplicable items
                            return TRUE;
                        }
                    }
                }
            } else if (pnm->code == NM_CLICK) {
                // Handle clicks to toggle Skip state in column 2
                HWND hListLocal = GetDlgItem(hwnd, IDC_LISTVIEW);
                POINT pt; GetCursorPos(&pt); ScreenToClient(hListLocal, &pt);
                LVHITTESTINFO ht{}; ht.pt = pt;
                int idx = ListView_HitTest(hListLocal, &ht);
                if (idx >= 0) {
                    int sub = ht.iSubItem;
                    if (sub == 4) {
                        // toggle skip for this item
                        std::string id = g_packages[idx].first;
                        std::lock_guard<std::mutex> lk(g_packages_mutex);
                        auto it = g_skipped_versions.find(id);
                        if (it != g_skipped_versions.end()) {
                            // confirm unskip
                            if (MessageBoxW(hwnd, t("confirm_unskip").c_str(), t("app_title").c_str(), MB_YESNO | MB_ICONQUESTION) == IDYES) {
                                g_skipped_versions.erase(it);
                                SaveSkipConfig(g_locale);
                                PopulateListView(hListLocal);
                            }
                        } else {
                            // determine available version for this id and add to skip config, confirm
                            try {
                                auto avail = MapAvailableVersions();
                                std::string ver = "";
                                auto f = avail.find(id);
                                if (f != avail.end()) ver = f->second;
                                if (!ver.empty()) {
                                    if (MessageBoxW(hwnd, t("confirm_skip").c_str(), t("app_title").c_str(), MB_YESNO | MB_ICONQUESTION) == IDYES) {
                                        g_skipped_versions[id] = ver;
                                        SaveSkipConfig(g_locale);
                                        PopulateListView(hListLocal);
                                    }
                                } else {
                                    MessageBoxW(hwnd, L"Unable to determine version to skip.", t("app_title").c_str(), MB_OK | MB_ICONWARNING);
                                }
                            } catch(...) {}
                        }
                    }
                }
            } else if (pnm->code == NM_CUSTOMDRAW) {
                // Use custom draw for listview items to gray out NotApplicable text
                LPNMLVCUSTOMDRAW lvc = (LPNMLVCUSTOMDRAW)lParam;
                switch (lvc->nmcd.dwDrawStage) {
                case CDDS_PREPAINT:
                    return CDRF_NOTIFYITEMDRAW;
                case CDDS_ITEMPREPAINT: {
                    int idx = (int)lvc->nmcd.dwItemSpec;
                    // alternate background color for readability
                    if ((idx & 1) == 0) {
                        lvc->clrTextBk = GetSysColor(COLOR_WINDOW);
                    } else {
                        lvc->clrTextBk = RGB(250,250,240);
                    }
                    if (IsItemNotApplicable(idx)) {
                        lvc->clrText = RGB(160,160,160);
                    }
                    // request that our color choices be applied
                    return CDRF_NEWFONT;
                }
                }
            }
        }
        break;
    }
    case WM_COMMAND: {
        int id = LOWORD(wParam);
        if (id == IDC_COMBO_LANG && HIWORD(wParam) == CBN_SELCHANGE) {
            HWND hCombo = GetDlgItem(hwnd, IDC_COMBO_LANG);
                if (hCombo) {
                int sel = (int)SendMessageW(hCombo, CB_GETCURSEL, 0, 0);
                std::string newloc = (sel == 1) ? "no" : "en";
                g_locale = newloc;
                LoadLocaleFromFile(g_locale);
                SaveLocaleSetting(g_locale);
                // update UI texts
                UpdateLastUpdatedLabel(hwnd);
                SetWindowTextW(GetDlgItem(hwnd, IDC_CHECK_SELECTALL), t("select_all").c_str());
                SetWindowTextW(GetDlgItem(hwnd, IDC_BTN_UPGRADE), t("upgrade_now").c_str());
                SetWindowTextW(GetDlgItem(hwnd, IDC_BTN_REFRESH), t("refresh").c_str());
                // update listview column headers
                HWND hListLocal = GetDlgItem(hwnd, IDC_LISTVIEW);
                if (hListLocal) {
                    // update persistent header strings
                    g_colHeaders[0] = t("package_col");
                    g_colHeaders[1] = t("current_col");
                    g_colHeaders[2] = t("available_col");
                    g_colHeaders[3] = t("skip_col");
                    // update ListView columns (text copied from persistent buffers)
                    LVCOLUMNW col{};
                    col.mask = LVCF_TEXT;
                    for (int ci = 0; ci < 4; ++ci) {
                        col.pszText = (LPWSTR)g_colHeaders[ci].c_str();
                        SendMessageW(hListLocal, LVM_SETCOLUMNW, ci, (LPARAM)&col);
                    }
                    // also set header formats and text explicitly via header control
                    HWND hHeader = ListView_GetHeader(hListLocal);
                    if (hHeader) {
                        for (int ci = 0; ci < 4; ++ci) {
                            HDITEMW hi{};
                            hi.mask = HDI_FORMAT | HDI_TEXT;
                            if (ci == 0) hi.fmt = HDF_LEFT;
                            else if (ci == 1) hi.fmt = HDF_LEFT;
                            else if (ci == 2) hi.fmt = HDF_RIGHT;
                            else hi.fmt = HDF_CENTER;
                            hi.pszText = (LPWSTR)g_colHeaders[ci].c_str();
                            SendMessageW(hHeader, HDM_SETITEMW, ci, (LPARAM)&hi);
                        }
                    }
                }
                // update window title but do not translate app name
                std::wstring winTitle = std::wstring(L"WinUpdate - ") + t("app_window_suffix");
                SetWindowTextW(hwnd, winTitle.c_str());
                // Inform the user about the language change with an info icon
                MessageBoxW(hwnd, t("lang_changed").c_str(), t("app_title").c_str(), MB_OK | MB_ICONINFORMATION);
            }
            break;
        }
        if (id == IDC_BTN_REFRESH) {
            // update timestamp and start async refresh
            UpdateLastUpdatedLabel(hwnd);
            if (!g_refresh_in_progress.load()) PostMessageW(hwnd, WM_REFRESH_ASYNC, 1, 0);
            break;
        } else if (id == IDC_BTN_ABOUT) {
            ShowAboutDialog(hwnd);
            break;
        } else if (id == IDC_BTN_DONE) {
            // User clicked Done on the install panel: delete temp file, re-enable UI, refresh and close panel
            // delete last install file if present (worker intentionally left it until user acknowledged)
            try { if (!g_last_install_outfile.empty()) { DeleteFileW(g_last_install_outfile.c_str()); g_last_install_outfile.clear(); } } catch(...) {}
            // Re-enable main UI controls now that user dismissed the install panel
            if (hList) EnableWindow(hList, TRUE);
            if (hBtnRefresh) EnableWindow(hBtnRefresh, TRUE);
            if (hBtnUpgrade) EnableWindow(hBtnUpgrade, TRUE);
            EnableWindow(GetDlgItem(hwnd, IDC_CHECK_SELECTALL), TRUE);
            EnableWindow(GetDlgItem(hwnd, IDC_COMBO_LANG), TRUE);
            // trigger refresh (user requested) and then close panel
            if (!g_refresh_in_progress.load()) PostMessageW(hwnd, WM_REFRESH_ASYNC, 1, 0);
            // destroy the tracked install panel only
            if (g_hInstallPanel && IsWindow(g_hInstallPanel)) {
                DestroyWindow(g_hInstallPanel);
                g_hInstallPanel = NULL;
            }
            break;
        } else if (id == IDC_CHECK_SELECTALL) {
            // Toggle check state for all list items when Select all checkbox is toggled
            HWND hChk = GetDlgItem(hwnd, IDC_CHECK_SELECTALL);
            BOOL ch = (SendMessageW(hChk, BM_GETCHECK, 0, 0) == BST_CHECKED);
            CheckAllItems(hList, ch);
        } else if (id == IDC_CHECK_SKIPSELECTED) {
            // Skip feature is temporarily disabled to avoid accidental skips during testing
            MessageBoxW(hwnd, t("skip_disabled").c_str(), t("app_title").c_str(), MB_OK | MB_ICONINFORMATION);
        } else if (id == IDC_BTN_UPGRADE) {
            // Collect checked items (or all if Select all checked)
            std::vector<std::string> toInstall;
            BOOL allChecked = (SendMessageW(GetDlgItem(hwnd, IDC_CHECK_SELECTALL), BM_GETCHECK, 0, 0) == BST_CHECKED);
            int count = ListView_GetItemCount(hList);
            for (int i = 0; i < count; ++i) {
                if (allChecked || ListView_GetCheckState(hList, i)) {
                    LVITEMW lvi{};
                    wchar_t buf[512];
                    lvi.iItem = i; lvi.iSubItem = 0; lvi.mask = LVIF_TEXT | LVIF_PARAM; lvi.pszText = buf; lvi.cchTextMax = _countof(buf);
                    SendMessageW(hList, LVM_GETITEMW, 0, (LPARAM)&lvi);
                    int idx = (int)lvi.lParam;
                    if (idx >= 0 && idx < (int)g_packages.size()) {
                        toInstall.push_back(g_packages[idx].first);
                    }
                }
            }
            if (toInstall.empty()) {
                MessageBoxW(hwnd, t("your_system_updated").c_str(), t("app_title").c_str(), MB_OK | MB_ICONINFORMATION);
                break;
            }

            // create a temp file to capture elevated output; file will be deleted immediately after install finishes
            wchar_t tmpPath[MAX_PATH]; GetTempPathW(MAX_PATH, tmpPath);
            unsigned long long uniq = GetTickCount64();
            std::wstring outFile = std::wstring(tmpPath) + L"wup_install_" + std::to_wstring(uniq) + L".txt";
            // ensure file exists
            HANDLE hTmpCreate = CreateFileW(outFile.c_str(), GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
            if (hTmpCreate != INVALID_HANDLE_VALUE) CloseHandle(hTmpCreate);

            // disable main list and controls while installing (keep UI visible but greyed)
            EnableWindow(hList, FALSE);
            EnableWindow(GetDlgItem(hwnd, IDC_CHECK_SELECTALL), FALSE);
            EnableWindow(GetDlgItem(hwnd, IDC_BTN_REFRESH), FALSE);
            EnableWindow(GetDlgItem(hwnd, IDC_COMBO_LANG), FALSE);
            EnableWindow(hBtnUpgrade, FALSE);

            // create an in-window install panel replacing the list view area
            HINSTANCE hInst = GetModuleHandleW(NULL);
            const int IW = 600, IH = 284;
            // list view area originally at (10,60,600,284)
            // If a previous install panel exists (leftover), destroy it first
            if (g_hInstallPanel && IsWindow(g_hInstallPanel)) {
                DestroyWindow(g_hInstallPanel);
                g_hInstallPanel = NULL;
            }
            HWND hInstallPanel = CreateWindowExW(0, L"STATIC", NULL, WS_CHILD | WS_VISIBLE | SS_LEFT, 10, 60, IW, IH, hwnd, NULL, hInst, NULL);
            // remember panel handle globally so Done handler can target it specifically
            g_hInstallPanel = hInstallPanel;
            INITCOMMONCONTROLSEX icce{ sizeof(icce), ICC_PROGRESS_CLASS };
            InitCommonControlsEx(&icce);
            // status label just under title area (parent = panel)
            HWND hInstallStatus = CreateWindowExW(0, L"Static", t("loading_title").c_str(), WS_CHILD | WS_VISIBLE | SS_LEFT, 12, 4, IW-24, 20, hInstallPanel, NULL, hInst, NULL);
            // progress bar below status label (parent = panel)
            HWND hProg = CreateWindowExW(0, PROGRESS_CLASSW, NULL, WS_CHILD | WS_VISIBLE, 12, 28, IW-36, 20, hInstallPanel, NULL, hInst, NULL);
            SendMessageW(hProg, PBM_SETRANGE, 0, MAKELPARAM(0, (int)toInstall.size()));
            SendMessageW(hProg, PBM_SETPOS, 0, 0);
            // animation overlay control (drawn over the progress bar)
            // Use transparent extended style so the progress bar remains visible underneath
            HWND hAnim = CreateWindowExW(WS_EX_TRANSPARENT, L"STATIC", NULL, WS_CHILD | WS_VISIBLE, 12, 28, IW-36, 20, hInstallPanel, NULL, hInst, NULL);
            if (hAnim) {
                g_hInstallAnim = hAnim;
                SetWindowSubclass(hAnim, AnimSubclassProc, 0, 0);
                // timer at 300ms for smooth, subtle motion
                SetTimer(hAnim, 0xBEEF, 300, NULL);
                // match font used by list for the output control so text looks consistent
            }
            // output edit filling remaining area (parent = panel)
            HWND hOut = CreateWindowExW(WS_EX_CLIENTEDGE, L"EDIT", NULL, WS_CHILD | WS_VISIBLE | ES_MULTILINE | ES_READONLY | WS_VSCROLL | ES_AUTOVSCROLL,
                12, 56, IW-36, IH-96, hInstallPanel, NULL, hInst, NULL);
            // ensure output uses the same list font for better visual consistency
            if (hOut && g_hListFont) SendMessageW(hOut, WM_SETFONT, (WPARAM)g_hListFont, TRUE);
            // Done button to allow user to close panel after reading output
            // Create Done/Continue button as a child of the main window so WM_COMMAND is routed
            // to the main WndProc (controls parented to the panel would send WM_COMMAND to the panel).
            int btnX = 10 + (IW - 110);
            int btnY = 60 + (IH - 28);
            HWND hDone = CreateWindowExW(0, L"Button", t("continue").c_str(), WS_CHILD | WS_VISIBLE | WS_DISABLED | BS_PUSHBUTTON, btnX, btnY, 96, 24, hwnd, (HMENU)IDC_BTN_DONE, hInst, NULL);
            // use title font for the status label for clarity
            if (hInstallStatus && g_hTitleFont) SendMessageW(hInstallStatus, WM_SETFONT, (WPARAM)g_hTitleFont, TRUE);

            // build a single cmd line that echos markers and runs all winget commands, writing to the temp file
            std::wstring seq = L"echo WUP_BEGIN > \"" + outFile + L"\" & ";
                for (size_t i = 0; i < toInstall.size(); ++i) {
                    std::wstring idw(toInstall[i].begin(), toInstall[i].end());
                    if (i) seq += L" & ";
                    // echo begin marker, run winget synchronously, then append INSTALLED/FAILED using &&/|| to check exit code reliably
                    seq += L"echo ===BEGIN===" + idw + L" >> \"" + outFile + L"\" & ";
                    seq += L"winget upgrade --id \"" + idw + L"\" >> \"" + outFile + L"\" 2>&1";
                    seq += L" & ( if %ERRORLEVEL% EQU 0 ( echo INSTALLED:" + idw + L" >> \"" + outFile + L"\" ) else ( echo FAILED:" + idw + L" >> \"" + outFile + L"\" ) )";
                    // Note: using explicit if grouping to avoid parsing-time expansion; alternatively &&/|| could be used,
                    // but grouping here ensures correct association in a single /C invocation.
                }

            // run elevated cmd.exe /C "<seq>"
            SHELLEXECUTEINFOW sei{};
            sei.cbSize = sizeof(sei);
            sei.fMask = SEE_MASK_NOCLOSEPROCESS;
            sei.hwnd = hwnd;
            sei.lpVerb = L"runas";
            sei.lpFile = L"cmd.exe";
            std::wstring params = L"/C \"" + seq + L"\"";
            sei.lpParameters = params.c_str();
            sei.nShow = SW_HIDE;
            if (!ShellExecuteExW(&sei)) {
                MessageBoxW(hwnd, t("msg_error_elevate").c_str(), t("app_title").c_str(), MB_ICONERROR);
                // restore UI
                ShowWindow(hList, SW_SHOW);
                ShowWindow(GetDlgItem(hwnd, IDC_CHECK_SELECTALL), SW_SHOW);
                ShowWindow(GetDlgItem(hwnd, IDC_BTN_REFRESH), SW_SHOW);
                ShowWindow(GetDlgItem(hwnd, IDC_COMBO_LANG), SW_SHOW);
                // remove the temp file we created since elevate failed
                try { if (!outFile.empty()) DeleteFileW(outFile.c_str()); } catch(...) {}
            } else {
                // After launching elevated process, ensure our main window is visible and foregrounded
                // so the UI (install panel) is not lost behind other windows when UAC finishes.
                TryForceForegroundWindow(hwnd);
                // monitor temp file and process in background thread
                HANDLE hProc = sei.hProcess;
                std::wstring outFileCopy = outFile; // capture
                g_last_install_outfile = outFileCopy;
                int totalCount = (int)toInstall.size();
                // pass panel handle so WM_APP+4 can destroy it
                HWND hPanelCopy = hInstallPanel;
                HWND hStatusCopy = hInstallStatus;
                std::thread([hProc, outFileCopy, hPanelCopy, hStatusCopy, hProg, hOut, hwnd, totalCount]() mutable {
                    size_t installedCount = 0;
                    bool usingMbProgress = false;
                    std::unordered_set<std::string> seenBeginIds;
                    std::string currentPackageId;
                    std::string lastStatus;
                    const DWORD bufSize = 4096;
                    std::vector<char> buffer(bufSize);
                    std::string acc;
                    HANDLE hFile = INVALID_HANDLE_VALUE;
                    int currentIdx = 0;
                    // wait until file exists and can be opened for reading (shared)
                    for (int attempt = 0; attempt < 300; ++attempt) {
                        hFile = CreateFileW(outFileCopy.c_str(), GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
                        if (hFile != INVALID_HANDLE_VALUE) break;
                        DWORD wait = WaitForSingleObject(hProc, 100);
                        if (wait == WAIT_OBJECT_0) break;
                        Sleep(50);
                    }
                    LARGE_INTEGER lastPos; lastPos.QuadPart = 0;
                    while (true) {
                        if (hFile != INVALID_HANDLE_VALUE) {
                            LARGE_INTEGER filesize; filesize.QuadPart = 0;
                            if (GetFileSizeEx(hFile, &filesize)) {
                                if (filesize.QuadPart > lastPos.QuadPart) {
                                    LARGE_INTEGER move; move.QuadPart = lastPos.QuadPart;
                                    SetFilePointerEx(hFile, move, NULL, FILE_BEGIN);
                                    DWORD read = 0;
                                    if (ReadFile(hFile, buffer.data(), (DWORD)buffer.size(), &read, NULL) && read > 0) {
                                        lastPos.QuadPart += read;
                                        std::string chunk(buffer.data(), buffer.data() + read);
                                        // always append raw chunk to acc for marker detection and raw log
                                        acc.append(chunk);
                                        // Filter noisy lines (ASCII spinners, repeated progress blocks). Handle MB progress lines specially.
                                        std::string visible;
                                        try {
                                            static const std::regex spinnerRe(R"(^[\s\-\\\|\/\._\(\)\[\]]+$)");
                                            static const std::regex blockBarRe(R"([]{8,})");
                                            static const std::regex mbRe(R"((\d+)\s*(MB|MiB)\s*/\s*(\d+)\s*(MB|MiB))", std::regex::icase);
                                            std::istringstream ls(chunk);
                                            std::string line;
                                            while (std::getline(ls, line)) {
                                                // trim
                                                auto ltrim = [](std::string &s){ while(!s.empty() && (s.front()==' '||s.front()=='\t' || s.front()=='\r')) s.erase(s.begin()); };
                                                auto rtrim = [](std::string &s){ while(!s.empty() && (s.back()==' '||s.back()=='\t' || s.back()=='\r' || s.back()=='\n')) s.pop_back(); };
                                                ltrim(line); rtrim(line);
                                                if (line.empty()) continue;
                                                // preserve marker and result lines
                                                if (line.rfind("===BEGIN===", 0) == 0) { visible += line + "\r\n"; continue; }
                                                if (line.rfind("INSTALLED:", 0) == 0 || line.rfind("FAILED:", 0) == 0) { visible += line + "\r\n"; continue; }
                                                // suppress spinner-only or large block bars
                                                if (std::regex_match(line, spinnerRe)) continue;
                                                if (std::regex_search(line, blockBarRe)) continue;
                                                // detect MB progress lines to update progress bar
                                                std::smatch mm;
                                                if (std::regex_search(line, mm, mbRe)) {
                                                                                        try {
                                                                                            int cur = std::stoi(mm[1].str());
                                                                                            int tot = std::stoi(mm[3].str());
                                                                                            if (tot > 0) {
                                                                                                int pct = (int)std::min(100.0, (cur / (double)tot) * 100.0);
                                                                                                // switch progress bar to percent mode (0..100)
                                                                                                SendMessageW(hProg, PBM_SETMARQUEE, FALSE, 0);
                                                                                                SendMessageW(hProg, PBM_SETRANGE, 0, MAKELPARAM(0, 100));
                                                                                                SendMessageW(hProg, PBM_SETPOS, (WPARAM)pct, 0);
                                                                                                usingMbProgress = true;
                                                                                                // hide animation while showing MB progress
                                                                                                if (g_hInstallAnim) PostMessageW(hwnd, WM_APP+6, 0, 0);
                                                                                            }
                                                                                        } catch(...) {}
                                                    continue;
                                                }
                                                // otherwise append visible
                                                visible += line + "\r\n";
                                            }
                                        } catch(...) {}
                                        if (!visible.empty()) {
                                            std::wstring wchunk = Utf8ToWide(visible);
                                            int curLen = GetWindowTextLengthW(hOut);
                                            SendMessageW(hOut, EM_SETSEL, (WPARAM)curLen, (LPARAM)curLen);
                                            SendMessageW(hOut, EM_REPLACESEL, FALSE, (LPARAM)wchunk.c_str());
                                            SendMessageW(hOut, EM_SCROLLCARET, 0, 0);
                                        }
                                        // detect begin markers to update status "Installing X of Y" and avoid double-counting
                                        size_t posb = 0;
                                        while (true) {
                                            size_t p = acc.find("===BEGIN===", posb);
                                            if (p == std::string::npos) break;
                                            size_t start = p + strlen("===BEGIN===");
                                            size_t eol = acc.find_first_of("\r\n", start);
                                            std::string id = (eol==std::string::npos) ? acc.substr(start) : acc.substr(start, eol - start);
                                            // trim id
                                            auto trim = [](std::string &s){ while(!s.empty() && (s.back()=='\r' || s.back()=='\n')) s.pop_back(); while(!s.empty() && isspace((unsigned char)s.front())) s.erase(s.begin()); while(!s.empty() && isspace((unsigned char)s.back())) s.pop_back(); };
                                            trim(id);
                                            if (!id.empty() && seenBeginIds.find(id) == seenBeginIds.end()) {
                                                seenBeginIds.insert(id);
                                                currentIdx = (int)seenBeginIds.size();
                                                currentPackageId = id;
                                                // build concise status: Installing X/Y: id
                                                wchar_t sBuf[512];
                                                std::wstring wId = Utf8ToWide(id);
                                                swprintf(sBuf, _countof(sBuf), L"Installing %d of %d: %s", currentIdx, totalCount, wId.c_str());
                                                lastStatus = WideToUtf8(std::wstring(sBuf));
                                                SetWindowTextW(hStatusCopy, sBuf);
                                                // set progress bar to marquee and ensure animation is visible when starting install
                                                SendMessageW(hProg, PBM_SETMARQUEE, TRUE, 300);
                                                if (g_hInstallAnim) PostMessageW(hwnd, WM_APP+6, 1, 0);
                                            }
                                            posb = (eol==std::string::npos) ? acc.size() : eol + 1;
                                        }
                                        // look for INSTALLED markers in acc
                                        size_t pos = 0;
                                        while (true) {
                                            size_t p = acc.find("INSTALLED:", pos);
                                            if (p == std::string::npos) break;
                                            installedCount++;
                                            if (usingMbProgress) {
                                                // map overall installed count to percent
                                                int pct = (int)((installedCount * 100) / (std::max(1, totalCount)));
                                                SendMessageW(hProg, PBM_SETPOS, (WPARAM)pct, 0);
                                                // restore overall-count range
                                                SendMessageW(hProg, PBM_SETRANGE, 0, MAKELPARAM(0, totalCount));
                                                usingMbProgress = false;
                                                // restore marquee and show animation again
                                                SendMessageW(hProg, PBM_SETMARQUEE, TRUE, 300);
                                                if (g_hInstallAnim) PostMessageW(hwnd, WM_APP+6, 1, 0);
                                            } else {
                                                SendMessageW(hProg, PBM_SETPOS, (WPARAM)installedCount, 0);
                                            }
                                            pos = p + 10;
                                        }
                                        // keep a little tail in case markers are split across reads
                                        if (acc.size() > 8192) acc.erase(0, acc.size() - 4096);
                                    }
                                }
                            }
                        }
                        DWORD wait = WaitForSingleObject(hProc, 250);
                        if (wait == WAIT_OBJECT_0) break;
                        Sleep(100);
                    }
                    // final drain
                    if (hFile != INVALID_HANDLE_VALUE) {
                        DWORD read2 = 0;
                        while (ReadFile(hFile, buffer.data(), (DWORD)buffer.size(), &read2, NULL) && read2 > 0) {
                            std::string tail(buffer.data(), buffer.data() + read2);
                            std::wstring wtail = Utf8ToWide(tail);
                            int curLen2 = GetWindowTextLengthW(hOut);
                            SendMessageW(hOut, EM_SETSEL, (WPARAM)curLen2, (LPARAM)curLen2);
                            SendMessageW(hOut, EM_REPLACESEL, FALSE, (LPARAM)wtail.c_str());
                            SendMessageW(hOut, EM_SCROLLCARET, 0, 0);
                            acc.append(tail);
                        }
                        CloseHandle(hFile);
                    }
                    CloseHandle(hProc);
                    // delete the temp file now that process finished and file closed
                    try { /* keep file until user presses Done */ } catch(...) {}
                    // Notify UI that install finished and allow user to click Done
                    PostMessageW(hwnd, WM_INSTALL_DONE, (WPARAM)hPanelCopy, 0);
                    // Ensure the app comes forward after the elevated process finished
                    PostMessageW(hwnd, WM_APP+7, 0, 0);
                }).detach();
            }
        }
        else if (id == IDC_CHECK_SHOW_SKIPPED) {
            HWND hChk = GetDlgItem(hwnd, IDC_CHECK_SHOW_SKIPPED);
            BOOL show = (SendMessageW(hChk, BM_GETCHECK, 0, 0) == BST_CHECKED);
            HWND hListLocal = GetDlgItem(hwnd, IDC_LISTVIEW);
            if (show) {
                // populate list with skipped entries
                auto skipped = LoadSkippedMap();
                ListView_DeleteAllItems(hListLocal);
                LVITEMW lvi{}; lvi.mask = LVIF_TEXT | LVIF_PARAM;
                int i = 0;
                for (auto &p : skipped) {
                    std::wstring idw = Utf8ToWide(p.first);
                    std::wstring verw = Utf8ToWide(p.second);
                    lvi.iItem = i; lvi.iSubItem = 0; lvi.pszText = (LPWSTR)idw.c_str(); lvi.lParam = -1;
                    SendMessageW(hListLocal, LVM_INSERTITEMW, 0, (LPARAM)&lvi);
                    LVITEMW lv2{}; lv2.mask = LVIF_TEXT; lv2.iItem = i; lv2.iSubItem = 2; lv2.pszText = (LPWSTR)verw.c_str(); SendMessageW(hListLocal, LVM_SETITEMW, 0, (LPARAM)&lv2);
                    ++i;
                }
                // show Unskip button if we have skipped entries
                HWND hUn = GetDlgItem(hwnd, IDC_BTN_UNSKIP);
                if (hUn) {
                    if (i > 0) { ShowWindow(hUn, SW_SHOW); EnableWindow(hUn, TRUE); }
                    else { ShowWindow(hUn, SW_HIDE); }
                }
            } else {
                // normal refresh to repopulate list
                if (!g_refresh_in_progress.load()) PostMessageW(hwnd, WM_REFRESH_ASYNC, 1, 0);
                HWND hUn = GetDlgItem(hwnd, IDC_BTN_UNSKIP); if (hUn) ShowWindow(hUn, SW_HIDE);
            }
            break;
        } else if (id == IDC_BTN_UNSKIP) {
            // Unskip selected item in list
            HWND hListLocal = GetDlgItem(hwnd, IDC_LISTVIEW);
            int sel = ListView_GetNextItem(hListLocal, -1, LVNI_SELECTED);
            if (sel >= 0) {
                wchar_t buf[512]; LVITEMW lvi{}; lvi.iItem = sel; lvi.iSubItem = 0; lvi.cchTextMax = _countof(buf); lvi.pszText = buf; lvi.mask = LVIF_TEXT; SendMessageW(hListLocal, LVM_GETITEMW, 0, (LPARAM)&lvi);
                std::string idUtf8 = WideToUtf8(std::wstring(buf));
                if (RemoveSkippedEntry(idUtf8)) {
                    // trigger immediate refresh scan
                    if (!g_refresh_in_progress.load()) PostMessageW(hwnd, WM_REFRESH_ASYNC, 1, 0);
                }
            }
            break;
        }
        break;
    }
    case WM_DESTROY:
        if (g_hLastUpdatedFont) {
            DeleteObject(g_hLastUpdatedFont);
            g_hLastUpdatedFont = NULL;
        }
        if (g_hTitleFont) {
            DeleteObject(g_hTitleFont);
            g_hTitleFont = NULL;
        }
        if (g_hInstallPanel && IsWindow(g_hInstallPanel)) {
            DestroyWindow(g_hInstallPanel);
            g_hInstallPanel = NULL;
        }
        PostQuitMessage(0);
        return 0;
    }
    return DefWindowProcW(hwnd, uMsg, wParam, lParam);
}

int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE, PWSTR, int nCmdShow) {
    // Very-early probe: log-only (internal MessageBox removed)
    try { WriteWorkspaceLogW(L"probe_very_early.txt", std::string("probe_very_early entry\n")); } catch(...) {}
    try { WriteWorkspaceLogW(L"probe_very_early.txt", std::string("probe_very_early no-box\n")); } catch(...) {}
    // Startup probe: record to desktop log instead of showing blocking MessageBox
    try {
        WriteToDesktop(L"wup_wwinmain_start_desktop.txt", std::string("wWinMain start PID=" + std::to_string(GetCurrentProcessId()) + "\n"));
    } catch(...) {}
    try { WriteWorkspaceLogW(L"probe_wwinmain_logged.txt", std::string("wWinMain reached PID=" + std::to_string(GetCurrentProcessId()) + "\n")); } catch(...) {}
    WNDCLASSW wc = { };
    wc.lpfnWndProc = WndProc;
    wc.hInstance = hInstance;
    wc.lpszClassName = CLASS_NAME;
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);

    if (!RegisterClassW(&wc)) return 0;

    // Initialize translations: prefer saved language, then environment/OS locale
    InitDefaultTranslations();
    // First check settings file for saved language
    std::string saved = LoadLocaleSetting();
    if (!saved.empty()) {
        g_locale = saved;
    } else {
        // try to read environment LANG or LC_ALL
        char *env = nullptr;
        size_t envsz = 0;
        std::string sysloc;
        try {
            if (_dupenv_s(&env, &envsz, "LANG") == 0 && env) sysloc = std::string(env);
            else if (_dupenv_s(&env, &envsz, "LC_ALL") == 0 && env) sysloc = std::string(env);
        } catch(...) { }
        if (env) { free(env); env = nullptr; }
        if (!sysloc.empty()) {
            size_t p = sysloc.find_first_of("._");
            std::string prefix = (p==std::string::npos) ? sysloc : sysloc.substr(0,p);
            g_locale = prefix;
        }
        if (g_locale.empty()) {
            WCHAR buf[32] = {0};
            if (GetUserDefaultLocaleName(buf, (int)std::size(buf))) {
                std::wstring wln(buf);
                if (wln.size() >= 2) g_locale = std::string(wln.begin(), wln.begin()+2);
            }
        }
        if (g_locale.empty()) g_locale = "en";
    }
    // attempt to load translations for the locale
    LoadLocaleFromFile(g_locale);
    // load per-locale skip configuration
    LoadSkipConfig(g_locale);

    std::wstring winTitle = std::wstring(L"WinUpdate - ") + t("app_window_suffix");
    // Early desktop-visible marker so we can confirm process start and environment
    try {
        std::string s = "WinMain about to CreateWindow PID=" + std::to_string(GetCurrentProcessId()) + " TS=" + WideToUtf8(GetTimestampNow()) + "\n";
        WriteToDesktop(L"wup_winmain_start_desktop.txt", s);
    } catch(...) {}

    // Spawn probe before creating the main window so we can observe earliest state
    try {
        SpawnProbeMessageBoxAt(100,100, L"Probe: pre-CreateWindow", L"Probe launched before CreateWindow");
    } catch(...) {}

    // Also attempt a direct CreateProcessW spawn with explicit application name
    try {
        std::wstring exePath = L"C:\\Users\\NalleBerg\\Documents\\C++\\Workspace\\WinUpdate\\tools\\msgbox_probe.exe";
        std::wstring args = L" 120 120 \"Startup probe\" \"Spawned via direct CreateProcess\"";
        std::wstring cmdline = L"\"" + exePath + L"\"" + args;
        STARTUPINFOW si{}; PROCESS_INFORMATION pi{}; si.cb = sizeof(si);
        BOOL ok = CreateProcessW(exePath.c_str(), &cmdline[0], NULL, NULL, FALSE, CREATE_NEW_CONSOLE, NULL, NULL, &si, &pi);
        int lasterr = ok ? 0 : (int)GetLastError();
        if (ok) {
            // Close handles so detached child won't keep process open
            CloseHandle(pi.hThread);
            CloseHandle(pi.hProcess);
        }
        std::string log = "DirectSpawn: exe=" + WideToUtf8(exePath) + " ok=" + (ok?"1":"0") + " err=" + std::to_string(lasterr) + "\n";
        try { WriteWorkspaceLogW(L"probe_direct_spawn.txt", log); } catch(...) {}
    } catch(...) {}

    // Workspace-absolute probe so we can confirm this routine executed and where files are written
    try {
        std::string s2 = "WinMain_probe PID=" + std::to_string(GetCurrentProcessId()) + " TS=" + WideToUtf8(GetTimestampNow()) + "\n";
        WriteWorkspaceLogW(L"probe_winmain.txt", s2);
    } catch(...) {}

    HWND hwnd = CreateWindowExW(0, CLASS_NAME, winTitle.c_str(), WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT, 640, 430, NULL, NULL, hInstance, NULL);
    if (!hwnd) return 0;
    // load and set application icons (embedded in resources)
    HICON hIconBig = (HICON)LoadImageW(hInstance, MAKEINTRESOURCEW(IDI_APP_ICON), IMAGE_ICON, 48, 48, LR_DEFAULTCOLOR);
    HICON hIconSmall = (HICON)LoadImageW(hInstance, MAKEINTRESOURCEW(IDI_APP_ICON), IMAGE_ICON, 16, 16, LR_DEFAULTCOLOR);
    if (hIconBig) SendMessageW(hwnd, WM_SETICON, ICON_BIG, (LPARAM)hIconBig);
    if (hIconSmall) SendMessageW(hwnd, WM_SETICON, ICON_SMALL, (LPARAM)hIconSmall);
    ShowWindow(hwnd, nCmdShow);
    // Keep auto-exit after 15000 ms so tests don't hang; ensure termination even if window message fails
    try {
        HWND hMain = hwnd;
        std::thread([hMain]() {
            std::this_thread::sleep_for(std::chrono::milliseconds(15000));
            try {
                if (IsWindow(hMain)) {
                    PostMessageW(hMain, WM_CLOSE, 0, 0);
                    std::this_thread::sleep_for(std::chrono::milliseconds(500));
                }
            } catch(...) {}
            // If still running, force-terminate the process to avoid hanging tests
            TerminateProcess(GetCurrentProcess(), 0);
        }).detach();
    } catch(...) {}

    MSG msg{};
    while (GetMessageW(&msg, NULL, 0, 0)) {
        TranslateMessage(&msg);
        DispatchMessageW(&msg);
    }
    return 0;
}
    case WM_REAPPLY_HEADERS: {
        // Reapply header text, formats and column fmt after initial layout
        HWND hListLocal = GetDlgItem(hwnd, IDC_LISTVIEW);
        try {
            std::string s = "WM_REAPPLY_HEADERS_probe PID=" + std::to_string(GetCurrentProcessId()) + " TS=" + WideToUtf8(GetTimestampNow()) + "\n";
            WriteWorkspaceLogW(L"probe_reapply.txt", s);
        } catch(...) {}
        if (hListLocal) {
            // Ensure persistent strings exist
            if (g_colHeaders.size() < 4) {
                g_colHeaders.clear();
                g_colHeaders.push_back(t("package_col"));
                g_colHeaders.push_back(t("current_col"));
                g_colHeaders.push_back(t("available_col"));
                g_colHeaders.push_back(t("skip_col"));
            }
            // Re-set ListView columns with fmt + text
            for (int ci = 0; ci < 4; ++ci) {
                LVCOLUMNW setcol{};
                setcol.mask = LVCF_FMT | LVCF_TEXT;
                if (ci == 0) setcol.fmt = LVCFMT_LEFT;
                else if (ci == 1) setcol.fmt = LVCFMT_RIGHT;
                else if (ci == 2) setcol.fmt = LVCFMT_RIGHT;
                else setcol.fmt = LVCFMT_CENTER;
                setcol.pszText = (LPWSTR)g_colHeaders[ci].c_str();
                SendMessageW(hListLocal, LVM_SETCOLUMNW, ci, (LPARAM)&setcol);
            }
            // Also set header items explicitly
            HWND hHeader = ListView_GetHeader(hListLocal);
            if (hHeader) {
                // set a readable font for header
                HFONT hf = (HFONT)SendMessageW(hListLocal, WM_GETFONT, 0, 0);
                if (hf) SendMessageW(hHeader, WM_SETFONT, (WPARAM)hf, TRUE);
                for (int ci = 0; ci < 4; ++ci) {
                    HDITEMW hi{};
                    hi.mask = HDI_FORMAT | HDI_TEXT;
                    if (ci == 0) hi.fmt = HDF_LEFT;
                    else if (ci == 1) hi.fmt = HDF_LEFT;
                    else if (ci == 2) hi.fmt = HDF_RIGHT;
                    else hi.fmt = HDF_CENTER;
                    hi.pszText = (LPWSTR)g_colHeaders[ci].c_str();
                    SendMessageW(hHeader, HDM_SETITEMW, ci, (LPARAM)&hi);
                }
                // Read back header items via HDM_GETITEMW to verify control state
                try {
                    std::ofstream vdbg("logs/wup_ui_setitems_verbose.txt", std::ios::binary | std::ios::app);
                    if (vdbg) {
                        vdbg << "-- HDM_GETITEMW results --\n";
                        for (int ci = 0; ci < 4; ++ci) {
                            wchar_t buff[256] = {0};
                            HDITEMW ghi{};
                            ghi.mask = HDI_TEXT | HDI_FORMAT;
                            ghi.pszText = buff;
                            ghi.cchTextMax = (int)std::size(buff);
                            BOOL ok = (BOOL)SendMessageW(hHeader, HDM_GETITEMW, ci, (LPARAM)&ghi);
                            vdbg << ci << ": OK=" << (ok?1:0) << " FMT=" << ghi.fmt << " TXT=" << WideToUtf8(std::wstring(buff)) << "\n";
                        }
                        vdbg << "-- end HDM_GETITEMW --\n";
                        vdbg.close();
                    }
                    // Also write a distinct debug marker file so it's easy to find when the handler executes
                    try {
                        std::ofstream marker("logs/header_debug_executed.txt", std::ios::binary | std::ios::app);
                        if (marker) {
                            marker << "WM_REAPPLY_HEADERS executed PID=" << GetCurrentProcessId() << " TS=" << WideToUtf8(GetTimestampNow()) << "\n";
                            for (size_t ci = 0; ci < g_colHeaders.size(); ++ci) marker << ci << ": " << WideToUtf8(g_colHeaders[ci]) << "\n";
                            marker << "----\n";
                            marker.close();
                        }
                    } catch(...) {}
                    // write desktop-visible marker too
                    try {
                        std::string accum = "WM_REAPPLY_HEADERS PID=" + std::to_string(GetCurrentProcessId()) + "\n";
                        for (size_t ci = 0; ci < g_colHeaders.size(); ++ci) accum += std::to_string(ci) + ": " + WideToUtf8(g_colHeaders[ci]) + "\n";
                        WriteToDesktop(L"wup_header_reapply_desktop.txt", accum);
                    } catch(...) {}
                } catch(...) {}
                InvalidateRect(hHeader, NULL, TRUE);
                UpdateWindow(hHeader);
                // Show a one-time MessageBox for debug visibility when the reapply handler runs
                try {
                    if (!g_reapply_msg_shown) {
                        g_reapply_msg_shown = true;
                        std::wstring msg = L"WM_REAPPLY_HEADERS executed.\nHeaders:\n";
                        for (size_t i = 0; i < g_colHeaders.size(); ++i) {
                            msg += g_colHeaders[i] + L"\n";
                        }
                        MessageBoxW(hwnd, msg.c_str(), L"WinUpdate: Header Reapply", MB_OK | MB_ICONINFORMATION);
                    }
                } catch(...) {}
            }
            RedrawWindow(hListLocal, NULL, NULL, RDW_INVALIDATE | RDW_ERASE | RDW_FRAME | RDW_UPDATENOW);
            // Log to verbose file that reapply ran
            try {
                std::ofstream vdbg("logs/wup_ui_setitems_verbose.txt", std::ios::binary | std::ios::app);
                if (vdbg) {
                    vdbg << "WM_REAPPLY_HEADERS PID=" << GetCurrentProcessId() << "\n";
                    for (size_t i = 0; i < g_colHeaders.size(); ++i) vdbg << i << ": " << WideToUtf8(g_colHeaders[i]) << "\n";
                    vdbg << "END_WM_REAPPLY\n";
                    vdbg.close();
                }
            } catch(...) {}
        }
        return 0;
    }

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) {
    // Very early startup marker to confirm process started and environment variables
    try {
        WriteToDesktop(L"wup_startup_marker.txt", std::string("WinMain started PID=") + std::to_string(GetCurrentProcessId()) + "\n");
    } catch(...) {}
    // absolute workspace probe at WinMain entry (not wWinMain) to ensure this process executed
    try {
        std::string s = "WinMain_probe PID=" + std::to_string(GetCurrentProcessId()) + " TS=" + WideToUtf8(GetTimestampNow()) + "\n";
        WriteWorkspaceLogW(L"probe_winmain_entry.txt", s);
    } catch(...) {}
    // Also write a workspace-local startup marker to avoid Desktop write issues
    try {
        std::ofstream ofs("logs/startup_marker_local.txt", std::ios::binary | std::ios::trunc);
        if (ofs) {
            ofs << "WinMain started PID=" << GetCurrentProcessId() << "\n";
            wchar_t cwdBuf[MAX_PATH] = {0};
            if (GetCurrentDirectoryW((DWORD)std::size(cwdBuf), cwdBuf)) {
                ofs << "CWD=" << WideToUtf8(std::wstring(cwdBuf)) << "\n";
            }
            ofs.close();
        }
    } catch(...) {}

    // Clean up noisy test/probe files so logs directory stays readable during iterative testing
    try {
        const wchar_t *delList[] = {
            L"logs\\probe_winmain.txt",
            L"logs\\probe_winmain_entry.txt",
            L"logs\\probe_reapply.txt",
            L"logs\\probe_header_paint.txt",
            L"logs\\header_paint.txt",
            L"logs\\header_debug_executed.txt",
            L"logs\\header_create.txt"
        };
        for (auto p : delList) {
            // ignore failures
            DeleteFileW(p);
        }
    } catch(...) {}
    LPWSTR cmdLineW = GetCommandLineW();
    // If invoked with --debug-parse, run winget (text) and print parsed entries to console then exit
    std::wstring cmdLine(cmdLineW ? cmdLineW : L"");
    if (cmdLine.find(L"--debug-parse") != std::wstring::npos) {
        // create a console to print results
        AllocConsole();
        FILE *f;
        freopen_s(&f, "CONOUT$", "w", stdout);
        // Read the run log (it contains prior winget captures which are more stable)
        std::string logtxt = ReadFileUtf8(L"wup_run_log.txt");
        if (logtxt.empty()) {
            // fallback to running winget directly
            std::wstring cmd = L"cmd /C winget upgrade --accept-source-agreements --accept-package-agreements";
            auto res = RunProcessCaptureExitCode(cmd, 15000);
            logtxt = res.second;
        }
        if (logtxt.empty()) {
            printf("No winget output available (run log empty).\n");
        } else {
            // Try fast parse of fresh winget upgrade output first
            std::set<std::pair<std::string,std::string>> found;
            std::wstring cmd = L"cmd /C winget upgrade --accept-source-agreements --accept-package-agreements";
            auto res = RunProcessCaptureExitCode(cmd, 15000);
            std::string listOut;
            if (!res.second.empty()) {
                // prefer list-based mapping first
                auto resList = RunProcessCaptureExitCode(L"cmd /C winget list", 8000);
                std::string listOut = resList.second;
                if (!listOut.empty() && !res.second.empty()) {
                    FindUpdatesUsingKnownList(listOut, res.second, found);
                }
                // If upgrade output indicates the 'not applicable' banner, mark list-based candidates as NotApplicable
                bool sawNotApplicable = (res.second.find("A newer package version is available in a configured source, but it does not apply to your system or requirements") != std::string::npos);
                if (sawNotApplicable && !listOut.empty()) {
                    // If winget reports 'not applicable', avoid trusting the whitespace parser (it can produce false positives).
                    // Instead, collect NotApplicable ids from the list output and report them.
                    std::istringstream lss2(listOut);
                    std::string line3;
                    std::set<std::string> localNA2;
                    std::regex anyRe2("([\\S ]+?)\\s+([^\\s]+)\\s+(\\S+)\\s+(\\S+)");
                    std::smatch m3;
                    while (std::getline(lss2, line3)) {
                        if (std::regex_search(line3, m3, anyRe2)) {
                            std::string id = m3[2].str();
                            std::string installed = m3[3].str();
                            std::string available = m3[4].str();
                            try { if (CompareVersions(installed, available) < 0) localNA2.insert(id); } catch(...) {}
                        }
                    }
                    if (!localNA2.empty()) {
                        printf("No applicable updates (all candidates are NotApplicable)\n");
                        printf("NotApplicable IDs:\n");
                        for (auto &s : localNA2) printf("%s\n", s.c_str());
                        return 0;
                    }
                }
                if (found.empty()) {
                    ParseUpgradeFast(res.second, found);
                }
                if (found.empty() && sawNotApplicable && !listOut.empty()) {
                    // collect ids from list where available > installed and report as NotApplicable
                    std::istringstream lss(listOut);
                    std::string line2;
                    std::set<std::string> localNA;
                    std::regex anyRe("([\\S ]+?)\\s+([^\\s]+)\\s+(\\S+)\\s+(\\S+)");
                    std::smatch m2;
                    while (std::getline(lss, line2)) {
                        if (std::regex_search(line2, m2, anyRe)) {
                            std::string id = m2[2].str();
                            std::string installed = m2[3].str();
                            std::string available = m2[4].str();
                            try { if (CompareVersions(installed, available) < 0) localNA.insert(id); } catch(...) {}
                        }
                    }
                    if (!localNA.empty()) {
                        printf("No applicable updates (all candidates are NotApplicable)\n");
                        printf("NotApplicable IDs:\n");
                        for (auto &s : localNA) printf("%s\n", s.c_str());
                        return 0;
                    }
                }
            }
            // If we have a list output, probe candidate ids for NotApplicable status
            std::set<std::string> candidateIds;
            if (!listOut.empty()) {
                std::istringstream lss(listOut);
                std::string lline;
                std::regex anyRe("([\\S ]+?)\\s+([^\\s]+)\\s+(\\S+)\\s+(\\S+)");
                std::smatch mm;
                while (std::getline(lss, lline)) {
                    if (std::regex_search(lline, mm, anyRe)) {
                        std::string id = mm[2].str();
                        std::string installed = mm[3].str();
                        std::string available = mm[4].str();
                        try { if (CompareVersions(installed, available) < 0) candidateIds.insert(id); } catch(...) {}
                    }
                }
            }

            std::set<std::string> localNA;
            // probe candidate ids that were not found by the generic parsing
            for (auto &id : candidateIds) {
                bool alreadyFound = false;
                for (auto &p : found) if (p.first == id) { alreadyFound = true; break; }
                if (alreadyFound) continue;
                // run per-id upgrade probe with short timeout
                std::wstring cmd = L"cmd /C winget upgrade --id \"" + std::wstring(id.begin(), id.end()) + L"\" --accept-source-agreements --accept-package-agreements";
                auto r = RunProcessCaptureExitCode(cmd, 2500);
                std::string out = r.second;
                if (out.find("does not apply to your system or requirements") != std::string::npos || out.find("No applicable upgrade found") != std::string::npos) {
                    localNA.insert(id);
                } else {
                    // if probe returns an applicable upgrade, try to extract id/name
                    std::set<std::pair<std::string,std::string>> f2;
                    ExtractUpdatesFromText(out, f2);
                    for (auto &pp : f2) if (pp.first == id) found.insert(pp);
                }
            }

            if (!localNA.empty()) {
                printf("NotApplicable IDs:\n");
                for (auto &s : localNA) printf("%s\n", s.c_str());
            }

            if (found.empty()) {
                printf("No updates found in run log.\n");
            } else {
                printf("Parsed packages (updates available):\n");
                for (auto &p : found) printf("Id: %s\tName: %s\n", p.first.c_str(), p.second.c_str());
            }
        }
        // exit immediately without pausing
        return 0;
    }
    return wWinMain(hInstance, hPrevInstance, cmdLineW, nCmdShow);
}
